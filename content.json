{"meta":{"title":"不怕万人阻挡，就怕自己投降","subtitle":null,"description":null,"author":"xiaoyi","url":"https://mr8649.github.io"},"pages":[],"posts":[{"title":"SpringBoot基础学习入门","slug":"SpringBoot基础学习入门","date":"2019-05-03T02:18:41.000Z","updated":"2019-05-03T02:21:30.750Z","comments":true,"path":"2019/05/03/SpringBoot基础学习入门/","link":"","permalink":"https://mr8649.github.io/2019/05/03/SpringBoot基础学习入门/","excerpt":"","text":"# 0.学习目标 - 了解SpringBoot的作用 - 掌握java配置的方式 - 了解SpringBoot自动配置原理 - 掌握SpringBoot的基本使用 - 了解Thymeleaf的基本使用 # 1. 了解SpringBoot 在这一部分，我们主要了解以下3个问题： - 什么是SpringBoot - 为什么要学习SpringBoot - SpringBoot的特点 ## 1.1.什么是SpringBoot SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： > Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： > 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 ## 1.2.为什么要学习SpringBoot java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： - 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 - 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ > Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 ## 1.3.SpringBoot的特点 Spring Boot 主要目标是： - 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 - 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 - 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 - 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 # 2.快速入门 接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ ## 2.1.创建工程 我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： ## 2.2.添加依赖 看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ ### 2.2.1.添加父工程坐标 \\123456789101112​ &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;​ &lt;/parent&gt;\\ ### 2.2.2.添加web启动器 为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： \\1234567891011121314​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;\\ 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 ### 2.2.3.管理jdk版本 默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： \\12345678​ &lt;properties&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;/properties&gt;\\ ### 2.2.4.完整pom \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt;​ &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt;​ &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;​ &lt;properties&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;/properties&gt;​ &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;​ &lt;/parent&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/project&gt;\\ ## 2.3.启动类 Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： \\1234567891011121314@SpringBootApplicationpublic class Application &#123;​ public static void main(String[] args) &#123;​ SpringApplication.run(Application.class, args);​ &#125;&#125;\\ ## 2.4.编写controller 接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： \\12345678910111213141516@RestControllerpublic class HelloController &#123;​ @GetMapping(\"hello\")​ public String hello()&#123;​ return \"hello, spring boot!\";​ &#125;&#125;\\ ## 2.5.启动测试 接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： - 1）监听的端口是8080 - 2）SpringMVC的映射路径是：/ - 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ # 3.Java配置 在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： \\12345678910111213141516&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"​ init-method=\"init\" destroy-method=\"close\"&gt;​ &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt;​ &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt;​ &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;\\ 现在该怎么做呢？ ## 3.1.回顾历史 事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： - Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 - Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 - Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 ## 3.2.尝试java配置 java配置主要靠java类和一些注解，比较常用的注解有： - @Configuration：声明一个类作为配置类，代替xml文件 - @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 - @value：属性注入 - @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： \\123456789101112&lt;dependency&gt;​ &lt;groupId&gt;com.alibaba&lt;/groupId&gt;​ &lt;artifactId&gt;druid&lt;/artifactId&gt;​ &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;\\ 创建一个jdbc.properties文件，编写jdbc属性： \\12345678910jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123\\ 然后编写代码： \\1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration@PropertySource(\"classpath:jdbc.properties\")public class JdbcConfig &#123;​ @Value(\"$&#123;jdbc.url&#125;\")​ String url;​ @Value(\"$&#123;jdbc.driverClassName&#125;\")​ String driverClassName;​ @Value(\"$&#123;jdbc.username&#125;\")​ String username;​ @Value(\"$&#123;jdbc.password&#125;\")​ String password;​ @Bean​ public DataSource dataSource() &#123;​ DruidDataSource dataSource = new DruidDataSource();​ dataSource.setUrl(url);​ dataSource.setDriverClassName(driverClassName);​ dataSource.setUsername(username);​ dataSource.setPassword(password);​ return dataSource;​ &#125;&#125;\\ 解读： - @Configuration：声明我们JdbcConfig是一个配置类 - @PropertySource：指定属性文件的路径是:classpath:jdbc.properties - 通过@Value为属性注入值 - 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： \\1234567891011121314151617181920@RestControllerpublic class HelloController &#123;​ @Autowired​ private DataSource dataSource;​ @GetMapping(\"hello\")​ public String hello() &#123;​ return \"hello, spring boot!\" + dataSource;​ &#125;&#125;\\ 然后Debug运行并查看： 属性注入成功了！ ## 3.3.SpringBoot的属性注入 在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： \\1234567891011121314151617181920@ConfigurationProperties(prefix = \"jdbc\")public class JdbcProperties &#123;​ private String url;​ private String driverClassName;​ private String username;​ private String password;​ // ... 略​ // getters 和 setters&#125;\\ - 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 - prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 - 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 - 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： \\12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123;​ @Bean​ public DataSource dataSource(JdbcProperties jdbc) &#123;​ DruidDataSource dataSource = new DruidDataSource();​ dataSource.setUrl(jdbc.getUrl());​ dataSource.setDriverClassName(jdbc.getDriverClassName());​ dataSource.setUsername(jdbc.getUsername());​ dataSource.setPassword(jdbc.getPassword());​ return dataSource;​ &#125;&#125;\\ - 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 - 然后你可以通过以下方式注入JdbcProperties： - @Autowired注入 ​ \\123456​ @Autowired​ private JdbcProperties prop;​ \\ - 构造函数注入 ​ \\12345678910​ private JdbcProperties prop;​ public JdbcConfig(Jdbcproperties prop)&#123;​ this.prop = prop;​ &#125;​ \\ - 声明有@Bean的方法参数注入 ​ \\12345678910​ @Bean​ public Datasource dataSource(JdbcProperties prop)&#123;​ // ...​ &#125;​ \\ 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： - Relaxed binding：松散绑定 - 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 - meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 ​ ## 3.4、更优雅的注入 事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： \\123456789101112131415161718192021222324@Configurationpublic class JdbcConfig &#123;​ ​ @Bean​ // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中​ @ConfigurationProperties(prefix = \"jdbc\")​ public DataSource dataSource() &#123;​ DruidDataSource dataSource = new DruidDataSource();​ return dataSource;​ &#125;&#125;\\ 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 4.自动配置原理 使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： - 注解：@SpringBootApplication - run方法：SpringApplication.run() 我们分别来研究这两个部分。 ## 4.1.了解@SpringBootApplication 点击进入，查看源码： 这里重点的注解有3个： - @SpringBootConfiguration - @EnableAutoConfiguration - @ComponentScan ### 4.1.1.@SpringBootConfiguration 我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 ### 4.1.2.@EnableAutoConfiguration 关于这个注解，官网上有一段说明： > The second class-level annotation is @EnableAutoConfiguration. This annotation > tells Spring Boot to “guess” how you want to configure Spring, based on the jar > dependencies that you have added. Since spring-boot-starter-web added Tomcat > and Spring MVC, the auto-configuration assumes that you are developing a web > application and sets up Spring accordingly. 简单翻译以下： > 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 #### 4.1.3.@ComponentScan 我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： > 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 > > 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 ## 4.2.默认配置原理 ### 4.2.1默认配置类 通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： - 这些默认配置是在哪里定义的呢？ - 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： - redis - jms - amqp - jdbc - jackson - mongodb - jpa - solr - elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： - @Configuration：声明这个类是一个配置类 - @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 - @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ - @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 ### 4.2.2.默认配置属性 另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 ## 4.3.总结 SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： - 你引入了相关依赖 - 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 # 5.SpringBoot实践 接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User ## 5.1.整合SpringMVC 虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 ### 5.1.1.修改端口 查看SpringBoot的全局属性可知，端口通过以下方式配置： \\123456\\# 映射端口server.port=80\\ 重启服务后测试： ### 5.1.2.访问静态资源 现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： - classpath:/META-INF/resources/ - classpath:/resources/ - classpath:/static/ - classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： ### 5.1.3.添加拦截器 拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： > If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. > > If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： > 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 > > 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： \\12345678910111213141516171819202122232425262728293031323334public class LoginInterceptor implements HandlerInterceptor &#123;​ private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);​ @Override​ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;​ logger.debug(\"preHandle method is now running!\");​ return true;​ &#125;​ @Override​ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;​ logger.debug(\"postHandle method is now running!\");​ &#125;​ @Override​ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;​ logger.debug(\"afterCompletion method is now running!\");​ &#125;&#125;\\ 然后，我们定义配置类，注册拦截器： \\123456789101112131415161718192021222324252627282930313233343536373839404142@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123;​ /**​ \\* 通过@Bean注解，将我们定义的拦截器注册到Spring容器​ \\* @return​ */​ @Bean​ public LoginInterceptor loginInterceptor()&#123;​ return new LoginInterceptor();​ &#125;​ /**​ \\* 重写接口中的addInterceptors方法，添加自定义拦截器​ \\* @param registry​ */​ @Override​ public void addInterceptors(InterceptorRegistry registry) &#123;​ // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径​ registry.addInterceptor(this.loginInterceptor()).addPathPatterns(\"/**\");​ &#125;&#125;\\ 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 \\123456\\# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug\\ 再次运行查看： \\123456782018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running!\\ ## 5.2.整合jdbc和事务 spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;\\ 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\\ 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional \\1234567891011121314151617181920212223242526@Servicepublic class UserService &#123;​ @Autowired​ private UserMapper userMapper;​ public User queryById(Long id)&#123;​ return this.userMapper.selectByPrimaryKey(id);​ &#125;​ @Transactional​ public void deleteById(Long id)&#123;​ this.userMapper.deleteByPrimaryKey(id);​ &#125;&#125;\\ ## 5.3.整合连接池 其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： \\1234567891011121314151617181920\\# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123\\# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10\\ 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： \\1234567891011121314&lt;!-- Druid连接池 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;com.alibaba&lt;/groupId&gt;​ &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;\\ 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： \\12345678910111213141516171819202122\\#初始化连接数spring.datasource.druid.initial-size=1\\#最小空闲连接spring.datasource.druid.min-idle=1\\#最大活动连接spring.datasource.druid.max-active=20\\#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true\\#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true\\ ## 5.4.整合mybatis ### 5.4.1.mybatis SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： \\1234567891011121314&lt;!--mybatis --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;\\ 配置，基本没有需要配置的： \\12345678910\\# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo\\# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml\\ 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 \\12345678@Mapperpublic interface UserMapper &#123;&#125;\\ ### 5.4.2.通用mapper 通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： \\1234567891011121314&lt;!-- 通用mapper --&gt;&lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\\ 不需要做任何配置就可以使用了。 \\12345678@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;\\ ## 5.5.启动测试 将controller进行简单改造： \\12345678910111213141516171819202122@RestControllerpublic class HelloController &#123;​ @Autowired​ private UserService userService;​ @GetMapping(\"/hello\")​ public User hello() &#123;​ User user = this.userService.queryById(8L);​ return user;​ &#125;&#125;\\ 我们启动项目，查看： # 6.Thymeleaf快速入门 SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ ## 6.1.为什么是Thymeleaf？ 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： - 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 - 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 - 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 - 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： ## 6.2.编写接口 编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 \\1234567891011121314151617181920@GetMapping(\"/all\")public String all(ModelMap model) &#123;​ // 查询用户​ List&lt;User&gt; users = this.userService.queryAll();​ // 放入模型​ model.addAttribute(\"users\", users);​ // 返回模板名称（就是classpath:/templates/目录下的html文件名）​ return \"users\";&#125;\\ ## 6.3.引入启动器 直接引入启动器： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\\ SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： - 默认前缀：classpath:/templates/ - 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 ## 6.4.静态页面 根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;​ &lt;title&gt;首页&lt;/title&gt; &lt;style type=\"text/css\"&gt;​ table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125;​ table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125;​ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"text-align: center\"&gt;​ &lt;span style=\"color: darkslategray; font-size: 30px\"&gt;欢迎光临！&lt;/span&gt;​ &lt;hr/&gt; &lt;table class=\"list\"&gt;​ &lt;tr&gt;​ &lt;th&gt;id&lt;/th&gt;​ &lt;th&gt;姓名&lt;/th&gt;​ &lt;th&gt;用户名&lt;/th&gt;​ &lt;th&gt;年龄&lt;/th&gt;​ &lt;th&gt;性别&lt;/th&gt;​ &lt;th&gt;生日&lt;/th&gt;​ &lt;th&gt;备注&lt;/th&gt;​ &lt;/tr&gt;​ &lt;tr th:each=\"user : $&#123;users&#125;\"&gt;​ &lt;td th:text=\"$&#123;user.id&#125;\"&gt;1&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.name&#125;\"&gt;张三&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.userName&#125;\"&gt;zhangsan&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.age&#125;\"&gt;20&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.sex&#125; == 1 ? '男': '女'\"&gt;男&lt;/td&gt;​ &lt;td th:text=\"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;\"&gt;1980-02-30&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.note&#125;\"&gt;1&lt;/td&gt;​ &lt;/tr&gt;​ &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\\ 我们看到这里使用了以下语法： - ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 - th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 - th:each：类似于c:foreach 遍历集合，但是语法更加简洁 - th:text：声明标签中的文本 ​ - 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 ​ - 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ ## 6.5.测试 接下来，我们打开页面测试一下： ## 6.6.模板缓存 Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： \\123456\\# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false\\ 注意： 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 eclipse中没有测试过。 我们可以修改页面，测试一下。","categories":[],"tags":[],"keywords":[]},{"title":"认识微服务","slug":"认识微服务","date":"2019-05-03T02:05:54.000Z","updated":"2019-05-03T02:12:32.425Z","comments":true,"path":"2019/05/03/认识微服务/","link":"","permalink":"https://mr8649.github.io/2019/05/03/认识微服务/","excerpt":"","text":"# 0.学习目标 - 了解系统架构的演变 - 了解RPC与Http的区别 - 掌握HttpClient的简单使用 - 知道什么是SpringCloud - 独立搭建Eureka注册中心 - 独立配置Robbin负载均衡 -Xms128m -Xmx128m # 1.系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 ## 1.1. 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： - 代码耦合，开发维护困难 - 无法针对不同模块进行针对性优化 - 无法水平扩展 - 单点容错率低，并发能力差 ## 1.2.垂直拆分 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： - 系统拆分实现了流量分担，解决了并发问题 - 可以针对不同模块进行优化 - 方便水平扩展，负载均衡，容错率提高 缺点： - 系统间相互独立，会有很多重复开发工作，影响开发效率 ## 1.3.分布式服务 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： - 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： - 系统间耦合度变高，调用关系错综复杂，难以维护 ## 1.4.服务治理（SOA） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ - 服务越来越多，需要管理每个服务的地址 - 调用关系错综复杂，难以理清依赖关系 - 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ - 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 - 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 - 动态监控服务状态监控报告，人为控制服务状态 缺点： - 服务间会有依赖关系，一旦某个环节出错会影响较大 - 服务关系复杂，运维、测试部署困难，不符合DevOps思想 ## 1.5.微服务 前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： - 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 - 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 - 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 - 自治：自治是说服务间互相独立，互不干扰 - 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 - 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 - 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 - 数据库分离：每个服务都使用自己的数据源 - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： # 2.远程调用方式 无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： - RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 - Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 ## 2.1.认识RPC RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： - 实现远程调用其他计算机的服务 - 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： ​ - 1）采用何种网络通讯协议？ ​ - 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 ​ - 2）数据传输的格式怎样？ ​ - 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 - 像调用本地服务一样调用远程服务 - 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC ## 2.2.认识Http Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 - RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 - Http中还定义了资源定位的路径，RPC中并不需要 - 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 - 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 - 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 ## 2.3.如何选择？ 既然两种方式都可以实现远程调用，我们该如何选择呢？ - 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 - 难度来看，RPC实现较为复杂，http相对比较简单 - 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： - 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 - 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 # 3.Http客户端工具 既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： - HttpClient - OKHttp - URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient ## 3.1.HttpClient ### 3.1.1.介绍 HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： - 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 - 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） - 支持HTTPS协议。 - 通过Http代理建立透明的连接。 - 自动处理Set-Cookie中的Cookie。 ### 3.1.2.使用 我们导入课前资料提供的demo工程：《http-demo》 发起get请求： \\1234567891011121314​ @Test​ public void testGet() throws IOException &#123;​ HttpGet request = new HttpGet(\"http://www.baidu.com\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);​ &#125;\\ 发起Post请求： \\123456789101112131415161718@Testpublic void testPost() throws IOException &#123;​ HttpPost request = new HttpPost(\"http://www.oschina.net/\");​ request.setHeader(\"User-Agent\",​ \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);&#125;\\ 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 \\1234567891011121314@Testpublic void testGetPojo() throws IOException &#123;​ HttpGet request = new HttpGet(\"http://localhost/hello\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);&#125;\\ 我们实际得到的是一个json字符串： \\1234567891011121314151617181920212223242526&#123;​ \"id\": 8,​ \"userName\": \"liuyan\",​ \"password\": \"123456\",​ \"name\": \"柳岩\",​ \"age\": 21,​ \"sex\": 2,​ \"birthday\": \"1995-08-07T16:00:00.000+0000\",​ \"created\": \"2014-09-20T03:41:15.000+0000\",​ \"updated\": \"2014-09-20T03:41:15.000+0000\",​ \"note\": \"柳岩同学在传智播客学表演\"&#125;\\ 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 ### 3.1.3.Json转换工具 HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： #### 对象转json \\12345678910111213141516171819202122232425262728// json处理工具​ private ObjectMapper mapper = new ObjectMapper();​ @Test​ public void testJson() throws JsonProcessingException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化​ String json = mapper.writeValueAsString(user);​ System.out.println(\"json = \" + json);​ &#125;\\ 结果： #### json转普通对象 \\1234567891011121314151617181920212223242526272829303132// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化​ String json = mapper.writeValueAsString(user);​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ User result = mapper.readValue(json, User.class);​ System.out.println(\"result = \" + result);&#125;\\ 结果： #### json转集合 json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： \\123456789101112131415161718192021222324252627282930313233343536// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化,得到对象集合的json字符串​ String json = mapper.writeValueAsString(Arrays.asList(user, user));​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class));​ for (User u : users) &#123;​ System.out.println(\"u = \" + u);​ &#125;&#125;\\ 结果： #### json转任意复杂类型 当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 \\123456789101112131415161718192021222324252627282930313233343536// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化,得到对象集合的json字符串​ String json = mapper.writeValueAsString(Arrays.asList(user, user));​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);​ for (User u : users) &#123;​ System.out.println(\"u = \" + u);​ &#125;&#125;\\ 结果： ## 3.3.Spring的RestTemplate Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： - HttpClient - OkHttp - JDK原生的URLConnection（默认的） 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： \\123456789101112131415161718192021222324@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123;​ // 默认的RestTemplate，底层是走JDK的URLConnection方式。​ return new RestTemplate(); &#125;&#125;\\ 在测试类中直接@Autowired注入： \\123456789101112131415161718192021222324@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123;​ User user = this.restTemplate.getForObject(\"http://localhost/hello\", User.class);​ System.out.println(user); &#125;&#125;\\ - 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 4.初始SpringCloud 微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ - 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 - 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 - 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 - 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 ## 4.1.简介 SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix - Eureka：注册中心 - Zuul：服务网关 - Ribbon：负载均衡 - Feign：服务调用 - Hystix：熔断器 以上只是其中一部分，架构图： ## 4.2.版本 SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： | Component | Edgware.SR3 | Finchley.RC1 | Finchley.BUILD-SNAPSHOT | | ————————- | ————– | —————- | ———————– | | spring-cloud-aws | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-bus | 1.3.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-cli | 1.4.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-commons | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-contract | 1.2.4.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-config | 1.4.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-netflix | 1.4.4.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-security | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-cloudfoundry | 1.1.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-consul | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-sleuth | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-stream | Ditmars.SR3 | Elmhurst.RELEASE | Elmhurst.BUILD-SNAPSHOT | | spring-cloud-zookeeper | 1.2.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-boot | 1.5.10.RELEASE | 2.0.1.RELEASE | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-task | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.RELEASE | | spring-cloud-vault | 1.1.0.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-gateway | 1.0.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-openfeign | | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | 接下来，我们就一一学习SpringCloud中的重要组件。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 5.微服务场景模拟 首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 ## 5.1.服务提供者 我们新建一个项目，对外提供查询用户的服务。 ### 5.1.1.Spring脚手架创建工程 借助于Spring提供的快速搭建工具： 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.3.2&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;​ &lt;scope&gt;runtime&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;​ &lt;scope&gt;test&lt;/scope&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;\\ 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： \\123456789101112&lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\\ 非常快捷啊！ ### 5.1.2.编写代码 添加一个对外查询的接口： \\12345678910111213141516171819202122@RestController@RequestMapping(\"user\")public class UserController &#123;​ @Autowired​ private UserService userService;​ @GetMapping(\"/&#123;id&#125;\")​ public User queryById(@PathVariable(\"id\") Long id) &#123;​ return this.userService.queryById(id);​ &#125;&#125;\\ Service： \\123456789101112131415161718@Servicepublic class UserService &#123;​ @Autowired​ private UserMapper userMapper;​ public User queryById(Long id) &#123;​ return this.userMapper.selectByPrimaryKey(id);​ &#125;&#125;\\ mapper: \\12345678@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;\\ 实体类： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Table(name = \"tb_user\")public class User implements Serializable &#123;​ private static final long serialVersionUID = 1L;​ @Id​ @GeneratedValue(strategy = GenerationType.IDENTITY)​ private Long id;​ // 用户名​ private String userName;​ // 密码​ private String password;​ // 姓名​ private String name;​ // 年龄​ private Integer age;​ // 性别，1男性，2女性​ private Integer sex;​ // 出生日期​ private Date birthday;​ // 创建时间​ private Date created;​ // 更新时间​ private Date updated;​ // 备注​ private String note; // 。。。省略getters和setters&#125;\\ 属性文件,这里我们采用了yaml语法，而不是properties： \\1234567891011121314151617181920212223242526server: port: 8081spring: datasource:​ url: jdbc:mysql://localhost:3306/mydb01​ username: root​ password: 123​ hikari:​ maximum-pool-size: 20​ minimum-idle: 10mybatis: type-aliases-package: com.leyou.userservice.pojo\\ 项目结构： ### 5.1.3.启动并测试： 启动项目，访问接口：http://localhost:8081/user/7 ## 5.2.服务调用者 ### 5.2.1.创建工程 与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： \\1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;!-- 添加OkHttp支持 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;​ &lt;artifactId&gt;okhttp&lt;/artifactId&gt;​ &lt;version&gt;3.9.0&lt;/version&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;\\ ### 5.2.2.编写代码 首先在启动类中注册RestTemplate： \\123456789101112131415161718192021222324@SpringBootApplicationpublic class UserConsumerDemoApplication &#123;​ @Bean​ public RestTemplate restTemplate() &#123;​ // 这次我们使用了OkHttp客户端,只需要注入工厂即可​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());​ &#125;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： \\1234567891011121314151617181920@Componentpublic class UserDao &#123;​ @Autowired​ private RestTemplate restTemplate;​ public User queryUserById(Long id)&#123;​ String url = \"http://localhost:8081/user/\" + id;​ return this.restTemplate.getForObject(url, User.class);​ &#125;&#125;\\ 然后编写user-service，循环查询UserDAO信息： \\12345678910111213141516171819202122232425262728@Servicepublic class UserService &#123;​ @Autowired​ private UserDao userDao;​ public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ for (Long id : ids) &#123;​ User user = this.userDao.queryUserById(id);​ users.add(user);​ &#125;​ return users;​ &#125;&#125;\\ 编写controller： \\12345678910111213141516171819202122@RestController@RequestMapping(\"consume\")public class ConsumerController &#123;​ @Autowired​ private UserService userService;​ @GetMapping​ public List&lt;User&gt; consume(@RequestParam(\"ids\") List&lt;Long&gt; ids) &#123;​ return this.userService.queryUserByIds(ids);​ &#125;&#125;\\ ### 5.2.3.启动测试： 因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume?ids=6,7,8 一个简单的远程服务调用案例就实现了。 ## 5.3.有没有问题？ 简单回顾一下，刚才我们写了什么： - use-service-demo：一个提供根据id查询用户的微服务 - consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ - 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 - consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 - consumer不清楚user-service的状态，服务宕机也不知道 - user-service只有1台服务，不具备高可用性 - 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： - 服务管理 - 如何自动注册和发现 - 如何实现状态监管 - 如何实现动态路由 - 服务如何实现负载均衡 - 服务如何解决容灾问题 - 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 6.Eureka注册中心 ## 6.1.认识Eureka 首先我们来解决第一问题，服务的管理。 > 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 > 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ > Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 ## 6.2.原理图 > 基本架构： - Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 - 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） - 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 - 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 ## 6.3.入门案例 ### 6.3.1.编写EurekaServer 接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;!-- SpringCloud版本，是最新的F系列 --&gt;​ &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;!-- Eureka服务端 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;\\ 编写启动类： \\12345678910111213141516@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125;\\ 编写配置： \\123456789101112131415161718192021222324server: port: 10086 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true​ fetch-registry: false # 是否拉取其它服务的信息，默认是true​ service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。​ defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka\\ 启动服务，并访问：http://127.0.0.1:10086/eureka ### 6.3.2.将user-service注册到Eureka 注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 > 我们在user-service-demo中添加Eureka客户端依赖： 先添加SpringCloud依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;Finchley.RC1&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;&lt;/repositories&gt;\\ 然后是Eureka客户端： \\123456789101112&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ > 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 \\12345678910111213141516@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125;\\ > 编写配置 \\1234567891011121314151617181920212223242526272829303132333435363738394041424344server: port: 8081spring: datasource:​ url: jdbc:mysql://localhost:3306/mydb01​ username: root​ password: 123​ hikari:​ maximum-pool-size: 20​ minimum-idle: 10 application:​ name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client:​ service-url: # EurekaServer地址​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称​ ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找\\ 注意： - 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 - 不用指定register-with-eureka和fetch-registry，因为默认是true > 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 ### 6.3.3.消费者从Eureka获取服务 接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;Finchley.RC1&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;&lt;/repositories&gt;\\ 然后是Eureka客户端： \\123456789101112&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ 2）在启动类开启Eureka客户端 \\123456789101112131415161718192021222324@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123;​ @Bean​ public RestTemplate restTemplate() &#123;​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());​ &#125;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ 3）修改配置： \\1234567891011121314151617181920212223242526server: port: 8080spring: application:​ name: consumer # 应用名称eureka: client:​ service-url: # EurekaServer地址​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname​ ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找\\ 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class UserService &#123;​ @Autowired​ private RestTemplate restTemplate;​ @Autowired​ private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ // String baseUrl = \"http://localhost:8081/user/\";​ // 根据服务名称，获取服务实例​ List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"user-service\");​ // 因为只有一个UserService,因此我们直接get(0)获取​ ServiceInstance instance = instances.get(0);​ // 获取ip和端口信息​ String baseUrl = \"http://\"+instance.getHost() + \":\" + instance.getPort()+\"/user/\";​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.restTemplate.getForObject(baseUrl + id, User.class));​ // 每次间隔500毫秒​ try &#123;​ Thread.sleep(500);​ &#125; catch (InterruptedException e) &#123;​ e.printStackTrace();​ &#125;​ &#125;);​ return users;​ &#125;&#125;\\ 5）Debug跟踪运行： 生成的URL： 访问结果： ## 6.4.Eureka详解 接下来我们详细讲解Eureka的原理及配置。 ### 6.4.1.基础架构 Eureka架构中的三个核心角色： - 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo - 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo - 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo ### 6.4.2.高可用的Eureka Server Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 > 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 > 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： \\1234567891011121314151617181920server: port: 10086 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087​ defaultZone: http://127.0.0.1:10087/eureka\\ 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： - 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 - 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： \\1234567891011121314151617181920server: port: 10087 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087​ defaultZone: http://127.0.0.1:10086/eureka\\ 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： \\12345678910eureka: client:​ service-url: # EurekaServer地址,多个地址以','隔开​ defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka\\ ### 6.4.3.服务提供者 服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 > 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 > 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： \\12345678910eureka: instance:​ lease-expiration-duration-in-seconds: 90​ lease-renewal-interval-in-seconds: 30\\ - lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 - lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 \\12345678910eureka: instance:​ lease-expiration-duration-in-seconds: 10 # 10秒即过期​ lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\\ > 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： - UP(1)：代表现在是启动了1个示例，没有集群 - DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， - 默认格式是：${hostname} + ${spring.application.name} + ${server.port} - instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： \\12345678eureka: instance:​ instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;\\ 重启服务再试试看： ### 6.4.4.服务消费者 > 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： \\12345678eureka: client:​ registry-fetch-interval-seconds: 5\\ 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 ### 6.4.5.失效剔除和自我保护 > 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S > 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： \\12345678910eureka: server:​ enable-self-preservation: false # 关闭自我保护模式（缺省为打开）​ eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）\\ 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 7.负载均衡Robbin 在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 ## 7.1.启动两个服务实例 首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： ## 7.2.开启负载均衡 因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： \\123456789101112@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123;​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125;\\ 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class UserService &#123;​ @Autowired​ private RestTemplate restTemplate;​ @Autowired​ private DiscoveryClient discoveryClient;​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ // 地址直接写服务名称即可​ String baseUrl = \"http://user-service/user/\";​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.restTemplate.getForObject(baseUrl + id, User.class));​ // 每次间隔500毫秒​ try &#123;​ Thread.sleep(500);​ &#125; catch (InterruptedException e) &#123;​ e.printStackTrace();​ &#125;​ &#125;);​ return users;​ &#125;&#125;\\ 访问页面，查看结果： 完美！ ## 7.3.源码跟踪 为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： ## 7.4.负载均衡策略 Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： \\12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123;​ @Autowired​ RibbonLoadBalancerClient client;​ @Test​ public void test()&#123;​ for (int i = 0; i &lt; 100; i++) &#123;​ ServiceInstance instance = this.client.choose(\"user-service\");​ System.out.println(instance.getHost() + \":\" + instance.getPort());​ &#125;​ &#125;&#125;\\ 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： \\12345678user-service: ribbon:​ NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\\ 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： ## 7.5.重试机制 Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： \\1234567891011121314151617181920212223242526spring: cloud:​ loadbalancer:​ retry:​ enabled: true # 开启Spring Cloud的重试功能user-service: ribbon:​ ConnectTimeout: 250 # Ribbon的连接超时时间​ ReadTimeout: 1000 # Ribbon的数据读取超时时间​ OkToRetryOnAllOperations: true # 是否对所有操作都进行重试​ MaxAutoRetriesNextServer: 1 # 切换实例的重试次数​ MaxAutoRetries: 1 # 对当前实例的重试次数\\ 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;​ &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt;\\ 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！","categories":[],"tags":[],"keywords":[]}]}