{"meta":{"title":"不怕万人阻挡，就怕自己投降","subtitle":null,"description":null,"author":"xiaoyi","url":"https://mr8649.github.io"},"pages":[],"posts":[{"title":"","slug":"day04-乐优商城项目搭建","date":"2019-05-03T02:12:01.052Z","updated":"2019-05-03T02:12:32.417Z","comments":true,"path":"2019/05/03/day04-乐优商城项目搭建/","link":"","permalink":"https://mr8649.github.io/2019/05/03/day04-乐优商城项目搭建/","excerpt":"","text":"0.学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ![1525686041466](assets/1525686041466.png) 1.2.2.数据来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​ 2.乐优商城介绍吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 3.项目搭建吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 3.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.1版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf 3.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 3.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 3.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 填写保存的位置信息： 然后将pom文件修改成我这个样子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 3.5.创建EurekaServer3.5.1.创建工程这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 3.5.2.添加依赖添加EurekaServer的依赖： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.5.3.编写启动类1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 3.5.4.配置文件1234567891011121314server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 3.5.5.项目的结构：目前，整个项目的结构如图： 3.6.创建Zuul网关3.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 3.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 3.6.4.配置文件123456789101112131415161718192021222324252627282930server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;zuul: prefix: /api # 添加路由前缀 retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 10000 # 熔断超时时长：10000ms 3.6.5.项目结构目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-api-gateway：服务网关（Zuul） 目前，服务的结构如图所示： ![1525709241440](assets/1525709241440.png) 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 3.7.创建商品微服务吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 3.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 3.7.2.创建父工程ly-item依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 3.7.3.创建ly-item-interface在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ​ 3.7.4.创建ly-item-service与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 3.7.5.整个微服务结构如图所示： ​ 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ​ 3.7.6.添加依赖接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ly-item-interface中需要什么我们暂时不清楚，所以先不管。 整个结构： 3.7.7.编写启动和配置在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819202122server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: 123 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 3.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 3.9.启动测试我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 3.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 3.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 4、ES6 语法指南吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 4.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 4.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 4.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 4.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 结果： const const声明的变量是常量，不能被修改 4.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 4.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 4.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: \"jack\", // 以前： eat: function (food) &#123; console.log(this.name + \"在吃\" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + \"在吃\" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + \"在吃\" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log(\"hello,\" + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log(\"hello,\" + name); 4.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 4.3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： 4.3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 4.3.8.模块化4.3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 4.3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = \"jack\"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 4.3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + \" , 今年\"+ age +\"岁了\") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 4.3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 4.3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[],"tags":[],"keywords":[]},{"title":"认识微服务","slug":"认识微服务","date":"2019-05-03T02:05:54.000Z","updated":"2019-05-03T02:12:32.425Z","comments":true,"path":"2019/05/03/认识微服务/","link":"","permalink":"https://mr8649.github.io/2019/05/03/认识微服务/","excerpt":"","text":"# 0.学习目标 - 了解系统架构的演变 - 了解RPC与Http的区别 - 掌握HttpClient的简单使用 - 知道什么是SpringCloud - 独立搭建Eureka注册中心 - 独立配置Robbin负载均衡 -Xms128m -Xmx128m # 1.系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 ## 1.1. 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： - 代码耦合，开发维护困难 - 无法针对不同模块进行针对性优化 - 无法水平扩展 - 单点容错率低，并发能力差 ## 1.2.垂直拆分 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： - 系统拆分实现了流量分担，解决了并发问题 - 可以针对不同模块进行优化 - 方便水平扩展，负载均衡，容错率提高 缺点： - 系统间相互独立，会有很多重复开发工作，影响开发效率 ## 1.3.分布式服务 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： - 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： - 系统间耦合度变高，调用关系错综复杂，难以维护 ## 1.4.服务治理（SOA） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ - 服务越来越多，需要管理每个服务的地址 - 调用关系错综复杂，难以理清依赖关系 - 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ - 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 - 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 - 动态监控服务状态监控报告，人为控制服务状态 缺点： - 服务间会有依赖关系，一旦某个环节出错会影响较大 - 服务关系复杂，运维、测试部署困难，不符合DevOps思想 ## 1.5.微服务 前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： - 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 - 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 - 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 - 自治：自治是说服务间互相独立，互不干扰 - 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 - 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 - 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 - 数据库分离：每个服务都使用自己的数据源 - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： # 2.远程调用方式 无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： - RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 - Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 ## 2.1.认识RPC RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： - 实现远程调用其他计算机的服务 - 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： ​ - 1）采用何种网络通讯协议？ ​ - 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 ​ - 2）数据传输的格式怎样？ ​ - 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 - 像调用本地服务一样调用远程服务 - 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC ## 2.2.认识Http Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 - RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 - Http中还定义了资源定位的路径，RPC中并不需要 - 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 - 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 - 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 ## 2.3.如何选择？ 既然两种方式都可以实现远程调用，我们该如何选择呢？ - 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 - 难度来看，RPC实现较为复杂，http相对比较简单 - 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： - 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 - 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 # 3.Http客户端工具 既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： - HttpClient - OKHttp - URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient ## 3.1.HttpClient ### 3.1.1.介绍 HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： - 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 - 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） - 支持HTTPS协议。 - 通过Http代理建立透明的连接。 - 自动处理Set-Cookie中的Cookie。 ### 3.1.2.使用 我们导入课前资料提供的demo工程：《http-demo》 发起get请求： \\1234567891011121314​ @Test​ public void testGet() throws IOException &#123;​ HttpGet request = new HttpGet(\"http://www.baidu.com\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);​ &#125;\\ 发起Post请求： \\123456789101112131415161718@Testpublic void testPost() throws IOException &#123;​ HttpPost request = new HttpPost(\"http://www.oschina.net/\");​ request.setHeader(\"User-Agent\",​ \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);&#125;\\ 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 \\1234567891011121314@Testpublic void testGetPojo() throws IOException &#123;​ HttpGet request = new HttpGet(\"http://localhost/hello\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);&#125;\\ 我们实际得到的是一个json字符串： \\1234567891011121314151617181920212223242526&#123;​ \"id\": 8,​ \"userName\": \"liuyan\",​ \"password\": \"123456\",​ \"name\": \"柳岩\",​ \"age\": 21,​ \"sex\": 2,​ \"birthday\": \"1995-08-07T16:00:00.000+0000\",​ \"created\": \"2014-09-20T03:41:15.000+0000\",​ \"updated\": \"2014-09-20T03:41:15.000+0000\",​ \"note\": \"柳岩同学在传智播客学表演\"&#125;\\ 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 ### 3.1.3.Json转换工具 HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： #### 对象转json \\12345678910111213141516171819202122232425262728// json处理工具​ private ObjectMapper mapper = new ObjectMapper();​ @Test​ public void testJson() throws JsonProcessingException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化​ String json = mapper.writeValueAsString(user);​ System.out.println(\"json = \" + json);​ &#125;\\ 结果： #### json转普通对象 \\1234567891011121314151617181920212223242526272829303132// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化​ String json = mapper.writeValueAsString(user);​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ User result = mapper.readValue(json, User.class);​ System.out.println(\"result = \" + result);&#125;\\ 结果： #### json转集合 json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： \\123456789101112131415161718192021222324252627282930313233343536// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化,得到对象集合的json字符串​ String json = mapper.writeValueAsString(Arrays.asList(user, user));​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class));​ for (User u : users) &#123;​ System.out.println(\"u = \" + u);​ &#125;&#125;\\ 结果： #### json转任意复杂类型 当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 \\123456789101112131415161718192021222324252627282930313233343536// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化,得到对象集合的json字符串​ String json = mapper.writeValueAsString(Arrays.asList(user, user));​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);​ for (User u : users) &#123;​ System.out.println(\"u = \" + u);​ &#125;&#125;\\ 结果： ## 3.3.Spring的RestTemplate Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： - HttpClient - OkHttp - JDK原生的URLConnection（默认的） 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： \\123456789101112131415161718192021222324@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123;​ // 默认的RestTemplate，底层是走JDK的URLConnection方式。​ return new RestTemplate(); &#125;&#125;\\ 在测试类中直接@Autowired注入： \\123456789101112131415161718192021222324@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123;​ User user = this.restTemplate.getForObject(\"http://localhost/hello\", User.class);​ System.out.println(user); &#125;&#125;\\ - 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 4.初始SpringCloud 微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ - 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 - 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 - 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 - 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 ## 4.1.简介 SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix - Eureka：注册中心 - Zuul：服务网关 - Ribbon：负载均衡 - Feign：服务调用 - Hystix：熔断器 以上只是其中一部分，架构图： ## 4.2.版本 SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： | Component | Edgware.SR3 | Finchley.RC1 | Finchley.BUILD-SNAPSHOT | | ————————- | ————– | —————- | ———————– | | spring-cloud-aws | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-bus | 1.3.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-cli | 1.4.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-commons | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-contract | 1.2.4.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-config | 1.4.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-netflix | 1.4.4.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-security | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-cloudfoundry | 1.1.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-consul | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-sleuth | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-stream | Ditmars.SR3 | Elmhurst.RELEASE | Elmhurst.BUILD-SNAPSHOT | | spring-cloud-zookeeper | 1.2.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-boot | 1.5.10.RELEASE | 2.0.1.RELEASE | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-task | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.RELEASE | | spring-cloud-vault | 1.1.0.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-gateway | 1.0.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-openfeign | | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | 接下来，我们就一一学习SpringCloud中的重要组件。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 5.微服务场景模拟 首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 ## 5.1.服务提供者 我们新建一个项目，对外提供查询用户的服务。 ### 5.1.1.Spring脚手架创建工程 借助于Spring提供的快速搭建工具： 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.3.2&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;​ &lt;scope&gt;runtime&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;​ &lt;scope&gt;test&lt;/scope&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;\\ 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： \\123456789101112&lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\\ 非常快捷啊！ ### 5.1.2.编写代码 添加一个对外查询的接口： \\12345678910111213141516171819202122@RestController@RequestMapping(\"user\")public class UserController &#123;​ @Autowired​ private UserService userService;​ @GetMapping(\"/&#123;id&#125;\")​ public User queryById(@PathVariable(\"id\") Long id) &#123;​ return this.userService.queryById(id);​ &#125;&#125;\\ Service： \\123456789101112131415161718@Servicepublic class UserService &#123;​ @Autowired​ private UserMapper userMapper;​ public User queryById(Long id) &#123;​ return this.userMapper.selectByPrimaryKey(id);​ &#125;&#125;\\ mapper: \\12345678@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;\\ 实体类： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Table(name = \"tb_user\")public class User implements Serializable &#123;​ private static final long serialVersionUID = 1L;​ @Id​ @GeneratedValue(strategy = GenerationType.IDENTITY)​ private Long id;​ // 用户名​ private String userName;​ // 密码​ private String password;​ // 姓名​ private String name;​ // 年龄​ private Integer age;​ // 性别，1男性，2女性​ private Integer sex;​ // 出生日期​ private Date birthday;​ // 创建时间​ private Date created;​ // 更新时间​ private Date updated;​ // 备注​ private String note; // 。。。省略getters和setters&#125;\\ 属性文件,这里我们采用了yaml语法，而不是properties： \\1234567891011121314151617181920212223242526server: port: 8081spring: datasource:​ url: jdbc:mysql://localhost:3306/mydb01​ username: root​ password: 123​ hikari:​ maximum-pool-size: 20​ minimum-idle: 10mybatis: type-aliases-package: com.leyou.userservice.pojo\\ 项目结构： ### 5.1.3.启动并测试： 启动项目，访问接口：http://localhost:8081/user/7 ## 5.2.服务调用者 ### 5.2.1.创建工程 与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： \\1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;!-- 添加OkHttp支持 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;​ &lt;artifactId&gt;okhttp&lt;/artifactId&gt;​ &lt;version&gt;3.9.0&lt;/version&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;\\ ### 5.2.2.编写代码 首先在启动类中注册RestTemplate： \\123456789101112131415161718192021222324@SpringBootApplicationpublic class UserConsumerDemoApplication &#123;​ @Bean​ public RestTemplate restTemplate() &#123;​ // 这次我们使用了OkHttp客户端,只需要注入工厂即可​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());​ &#125;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： \\1234567891011121314151617181920@Componentpublic class UserDao &#123;​ @Autowired​ private RestTemplate restTemplate;​ public User queryUserById(Long id)&#123;​ String url = \"http://localhost:8081/user/\" + id;​ return this.restTemplate.getForObject(url, User.class);​ &#125;&#125;\\ 然后编写user-service，循环查询UserDAO信息： \\12345678910111213141516171819202122232425262728@Servicepublic class UserService &#123;​ @Autowired​ private UserDao userDao;​ public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ for (Long id : ids) &#123;​ User user = this.userDao.queryUserById(id);​ users.add(user);​ &#125;​ return users;​ &#125;&#125;\\ 编写controller： \\12345678910111213141516171819202122@RestController@RequestMapping(\"consume\")public class ConsumerController &#123;​ @Autowired​ private UserService userService;​ @GetMapping​ public List&lt;User&gt; consume(@RequestParam(\"ids\") List&lt;Long&gt; ids) &#123;​ return this.userService.queryUserByIds(ids);​ &#125;&#125;\\ ### 5.2.3.启动测试： 因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume?ids=6,7,8 一个简单的远程服务调用案例就实现了。 ## 5.3.有没有问题？ 简单回顾一下，刚才我们写了什么： - use-service-demo：一个提供根据id查询用户的微服务 - consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ - 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 - consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 - consumer不清楚user-service的状态，服务宕机也不知道 - user-service只有1台服务，不具备高可用性 - 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： - 服务管理 - 如何自动注册和发现 - 如何实现状态监管 - 如何实现动态路由 - 服务如何实现负载均衡 - 服务如何解决容灾问题 - 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 6.Eureka注册中心 ## 6.1.认识Eureka 首先我们来解决第一问题，服务的管理。 > 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 > 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ > Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 ## 6.2.原理图 > 基本架构： - Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 - 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） - 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 - 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 ## 6.3.入门案例 ### 6.3.1.编写EurekaServer 接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;!-- SpringCloud版本，是最新的F系列 --&gt;​ &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;!-- Eureka服务端 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;\\ 编写启动类： \\12345678910111213141516@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125;\\ 编写配置： \\123456789101112131415161718192021222324server: port: 10086 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true​ fetch-registry: false # 是否拉取其它服务的信息，默认是true​ service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。​ defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka\\ 启动服务，并访问：http://127.0.0.1:10086/eureka ### 6.3.2.将user-service注册到Eureka 注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 > 我们在user-service-demo中添加Eureka客户端依赖： 先添加SpringCloud依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;Finchley.RC1&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;&lt;/repositories&gt;\\ 然后是Eureka客户端： \\123456789101112&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ > 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 \\12345678910111213141516@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125;\\ > 编写配置 \\1234567891011121314151617181920212223242526272829303132333435363738394041424344server: port: 8081spring: datasource:​ url: jdbc:mysql://localhost:3306/mydb01​ username: root​ password: 123​ hikari:​ maximum-pool-size: 20​ minimum-idle: 10 application:​ name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client:​ service-url: # EurekaServer地址​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称​ ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找\\ 注意： - 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 - 不用指定register-with-eureka和fetch-registry，因为默认是true > 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 ### 6.3.3.消费者从Eureka获取服务 接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;Finchley.RC1&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;&lt;/repositories&gt;\\ 然后是Eureka客户端： \\123456789101112&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ 2）在启动类开启Eureka客户端 \\123456789101112131415161718192021222324@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123;​ @Bean​ public RestTemplate restTemplate() &#123;​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());​ &#125;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ 3）修改配置： \\1234567891011121314151617181920212223242526server: port: 8080spring: application:​ name: consumer # 应用名称eureka: client:​ service-url: # EurekaServer地址​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname​ ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找\\ 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class UserService &#123;​ @Autowired​ private RestTemplate restTemplate;​ @Autowired​ private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ // String baseUrl = \"http://localhost:8081/user/\";​ // 根据服务名称，获取服务实例​ List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"user-service\");​ // 因为只有一个UserService,因此我们直接get(0)获取​ ServiceInstance instance = instances.get(0);​ // 获取ip和端口信息​ String baseUrl = \"http://\"+instance.getHost() + \":\" + instance.getPort()+\"/user/\";​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.restTemplate.getForObject(baseUrl + id, User.class));​ // 每次间隔500毫秒​ try &#123;​ Thread.sleep(500);​ &#125; catch (InterruptedException e) &#123;​ e.printStackTrace();​ &#125;​ &#125;);​ return users;​ &#125;&#125;\\ 5）Debug跟踪运行： 生成的URL： 访问结果： ## 6.4.Eureka详解 接下来我们详细讲解Eureka的原理及配置。 ### 6.4.1.基础架构 Eureka架构中的三个核心角色： - 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo - 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo - 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo ### 6.4.2.高可用的Eureka Server Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 > 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 > 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： \\1234567891011121314151617181920server: port: 10086 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087​ defaultZone: http://127.0.0.1:10087/eureka\\ 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： - 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 - 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： \\1234567891011121314151617181920server: port: 10087 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087​ defaultZone: http://127.0.0.1:10086/eureka\\ 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： \\12345678910eureka: client:​ service-url: # EurekaServer地址,多个地址以','隔开​ defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka\\ ### 6.4.3.服务提供者 服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 > 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 > 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： \\12345678910eureka: instance:​ lease-expiration-duration-in-seconds: 90​ lease-renewal-interval-in-seconds: 30\\ - lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 - lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 \\12345678910eureka: instance:​ lease-expiration-duration-in-seconds: 10 # 10秒即过期​ lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\\ > 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： - UP(1)：代表现在是启动了1个示例，没有集群 - DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， - 默认格式是：${hostname} + ${spring.application.name} + ${server.port} - instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： \\12345678eureka: instance:​ instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;\\ 重启服务再试试看： ### 6.4.4.服务消费者 > 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： \\12345678eureka: client:​ registry-fetch-interval-seconds: 5\\ 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 ### 6.4.5.失效剔除和自我保护 > 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S > 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： \\12345678910eureka: server:​ enable-self-preservation: false # 关闭自我保护模式（缺省为打开）​ eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）\\ 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 7.负载均衡Robbin 在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 ## 7.1.启动两个服务实例 首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： ## 7.2.开启负载均衡 因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： \\123456789101112@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123;​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125;\\ 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class UserService &#123;​ @Autowired​ private RestTemplate restTemplate;​ @Autowired​ private DiscoveryClient discoveryClient;​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ // 地址直接写服务名称即可​ String baseUrl = \"http://user-service/user/\";​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.restTemplate.getForObject(baseUrl + id, User.class));​ // 每次间隔500毫秒​ try &#123;​ Thread.sleep(500);​ &#125; catch (InterruptedException e) &#123;​ e.printStackTrace();​ &#125;​ &#125;);​ return users;​ &#125;&#125;\\ 访问页面，查看结果： 完美！ ## 7.3.源码跟踪 为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： ## 7.4.负载均衡策略 Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： \\12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123;​ @Autowired​ RibbonLoadBalancerClient client;​ @Test​ public void test()&#123;​ for (int i = 0; i &lt; 100; i++) &#123;​ ServiceInstance instance = this.client.choose(\"user-service\");​ System.out.println(instance.getHost() + \":\" + instance.getPort());​ &#125;​ &#125;&#125;\\ 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： \\12345678user-service: ribbon:​ NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\\ 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： ## 7.5.重试机制 Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： \\1234567891011121314151617181920212223242526spring: cloud:​ loadbalancer:​ retry:​ enabled: true # 开启Spring Cloud的重试功能user-service: ribbon:​ ConnectTimeout: 250 # Ribbon的连接超时时间​ ReadTimeout: 1000 # Ribbon的数据读取超时时间​ OkToRetryOnAllOperations: true # 是否对所有操作都进行重试​ MaxAutoRetriesNextServer: 1 # 切换实例的重试次数​ MaxAutoRetries: 1 # 对当前实例的重试次数\\ 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;​ &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt;\\ 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！","categories":[],"tags":[],"keywords":[]}]}