{"meta":{"title":"不怕万人阻挡，就怕自己投降","subtitle":null,"description":null,"author":"xiaoyi","url":"https://mr8649.github.io"},"pages":[],"posts":[{"title":"","slug":"day07-商品分类及品牌","date":"2019-04-21T02:54:38.625Z","updated":"2018-08-19T11:13:23.953Z","comments":true,"path":"2019/04/21/day07-商品分类及品牌/","link":"","permalink":"https://mr8649.github.io/2019/04/21/day07-商品分类及品牌/","excerpt":"","text":"0.学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 1.使用域名访问本地项目1.1.统一环境我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com， 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 1.2.域名解析一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 1234# My hosts127.0.0.1 localhost0.0.0.0 account.jetbrains.com127.0.0.1 www.xmind.net 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 1.3.解决域名解析问题我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 效果： 我们添加了两个映射关系： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ 1.4.nginx解决端口问题虽然域名解决了，但是现在如果我们要访问，还得自己加上端口：http://manage.taotao.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.taotao.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 1.4.1.什么是Nginx NIO：not-blocking-io 非阻塞IO BIO：blocking-IO 阻塞IO nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 1.4.2.nginx作为web服务器Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 Nginx + tomcat 1.4.3.nginx作为反向代理什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 1.4.4.安装和使用 安装 安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 我们在本地安装一台nginx： 目录结构： 使用 nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 1.5.测试启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 2.实现商品分类查询商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 因此，我们需要依次去完成：商品分类、品牌、商品的开发。 2.1.导入数据首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 2.2.页面实现2.2.1.页面分析首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 123456789101112&lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url=\"/item/category/list\" :treeData=\"treeData\" :isEdit=\"isEdit\" @handleAdd=\"handleAdd\" @handleEdit=\"handleEdit\" @handleDelete=\"handleDelete\" @handleClick=\"handleClick\" /&gt; &lt;/v-flex&gt;&lt;/v-card&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 2.2.2.树组件的用法也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; \"id\": 74, \"name\": \"手机\", \"parentId\": 0, \"isParent\": true, \"sort\": 2 &#125;, &#123; \"id\": 75, \"name\": \"家用电器\", \"parentId\": 0, \"isParent\": true, \"sort\": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含全部信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; \"id\": 76, // 节点id \"name\": \"手机\", // 节点名称 \"parentId\": 75, // 父节点id \"isParent\": false, // 是否是父节点 \"sort\": 1, // 顺序 \"path\": [\"手机\", \"手机通讯\", \"手机\"] // 所有父节点的名称数组&#125; 2.3.实现功能2.3.1.url异步请求给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url=\"/item/category/list\" :isEdit=\"isEdit\" @handleAdd=\"handleAdd\" @handleEdit=\"handleEdit\" @handleDelete=\"handleDelete\" @handleClick=\"handleClick\" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名： 再次查看页面，发现地址已经变成了正确的地址了： 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 2.3.2.实体类在ly-item-interface中添加category实体类： 123456789101112@Table(name=\"tb_category\")public class Category &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private Long parentId; private Boolean isParent; private Integer sort; // getter和setter略 // 注意isParent的get和set方法&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 结构： 2.3.3.controller编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; \"id\": 74, \"name\": \"手机\", \"parentId\": 0, \"isParent\": true, \"sort\": 2 &#125;, &#123; \"id\": 75, \"name\": \"家用电器\", \"parentId\": 0, \"isParent\": true, \"sort\": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。 controller代码： 12345678910111213141516171819202122@RestController@RequestMapping(\"category\")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父节点查询商品类目 * @param pid * @return */ @GetMapping(\"list\") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryByParentId( @RequestParam(value = \"pid\", defaultValue = \"0\") Long pid) &#123; List&lt;Category&gt; list = this.categoryService.queryListByParent(pid); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list); &#125;&#125; 2.3.4.service一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 123456789101112@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; public List&lt;Category&gt; queryListByParent(Long pid) &#123; Category category = new Category(); category.setParentId(pid); return this.categoryMapper.select(category); &#125;&#125; 2.3.5.mapper我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan(\"com.leyou.item.mapper\") // 扫描mapper包public class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 项目结构： 2.3.6.启动并测试我们不经过网关，直接访问： 然后试试网关是否畅通： 一切OK！ 然后刷新页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 2.4.跨域问题2.4.1.什么是跨域跨域是指跨域名的访问，以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 2.4.2.为什么有跨域问题？跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 2.4.3.解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 2.5.cors解决跨域2.5.1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 2.5.2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意 Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 注意： 如果跨域请求要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 2.5.3.实现非常简单虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在ly-api-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(\"http://manage.leyou.com\"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"HEAD\"); config.addAllowedMethod(\"GET\"); config.addAllowedMethod(\"PUT\"); config.addAllowedMethod(\"POST\"); config.addAllowedMethod(\"DELETE\"); config.addAllowedMethod(\"PATCH\"); // 4）允许的头信息 config.addAllowedHeader(\"*\"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 4.5.4.重启测试： 访问正常： 页面也OK了： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 3.品牌的查询商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 接下来，我们从0开始，实现下从前端到后端的完整开发。 3.1.从0开始为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容初始化一下： 123456789101112131415&lt;template&gt; &lt;span&gt; hello &lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 改变router新的index.js，将路由地址指向MyBrand.vue 打开服务器，再次查看页面： 干干净净了。 3.2.品牌查询页面3.2.1.data-tables组件大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 3.2.2.分析接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 12345678910&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行 search：搜索过滤字段，用不到，暂时不管 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 3.2.3.初步实现我们先弄点假品牌数据： 1234567891011121314151617181920212223242526272829303132[ &#123; \"id\": 2032, \"name\": \"OPPO\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg\", \"letter\": \"O\" &#125;, &#123; \"id\": 2033, \"name\": \"飞利浦（PHILIPS）\", \"image\": \"http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg\", \"letter\": \"F\" &#125;, &#123; \"id\": 2034, \"name\": \"华为（HUAWEI）\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg\", \"letter\": \"H\" &#125;, &#123; \"id\": 2036, \"name\": \"酷派（Coolpad）\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg\", \"letter\": \"K\" &#125;, &#123; \"id\": 2037, \"name\": \"魅族（MEIZU）\", \"image\": \"http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg\", \"letter\": \"M\" &#125;] 品牌中有id,name,image,letter字段。 修改模板123456789101112131415161718192021&lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt; &lt;span v-else&gt;无&lt;/span&gt; &lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/div&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 编写数据接下来编写要用到的数据： 1234567891011121314151617&#123; data() &#123; return &#123; search: '', // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125; ] &#125; &#125;&#125; 编写函数，初始化数据接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950methods:&#123; getDataFromServer()&#123; // 从服务的加载数据的方法。 // 伪造假数据 const brands = [ &#123; \"id\": 2032, \"name\": \"OPPO\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg\", \"letter\": \"O\", \"categories\": null &#125;, &#123; \"id\": 2033, \"name\": \"飞利浦（PHILIPS）\", \"image\": \"http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg\", \"letter\": \"F\", \"categories\": null &#125;, &#123; \"id\": 2034, \"name\": \"华为（HUAWEI）\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg\", \"letter\": \"H\", \"categories\": null &#125;, &#123; \"id\": 2036, \"name\": \"酷派（Coolpad）\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg\", \"letter\": \"K\", \"categories\": null &#125;, &#123; \"id\": 2037, \"name\": \"魅族（MEIZU）\", \"image\": \"http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg\", \"letter\": \"M\", \"categories\": null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer();&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125; ] &#125; &#125;, mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, methods:&#123; getDataFromServer()&#123; // 从服务的加载数的方法。 // 伪造假数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 刷新页面查看： 3.2.4.优化页面编辑和删除按钮我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列： 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。 我们先在头（headers）中添加一列： 1234567headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125;] 然后在模板中添加按钮： 123456789&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center&quot;&gt; 编辑/删除 &lt;/td&gt;&lt;/template&gt; 因为不知道按钮怎么写，先放个普通文本看看： 然后在官方文档中找到按钮的用法： 修改我们的模板： 12345678910&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt;&lt;/template&gt; 新增按钮因为新增根某个品牌无关，是独立的，因此我们可以放到表格的外面： 效果： 卡片（card）为了不让按钮显得过于孤立，我们可以将按新增按钮和表格放到一张卡片（card）中。 我们去官网查看卡片的用法： 卡片v-card包含四个基本组件： v-card-media：一般放图片或视频 v-card-title：卡片的标题，一般位于卡片顶部 v-card-text：卡片的文本（主体内容），一般位于卡片正中 v-card-action：卡片的按钮，一般位于卡片底部 我们可以把新增的按钮放到v-card-title位置，把table放到下面，这样就成一个上下关系。 1234567891011121314151617181920212223242526272829&lt;v-card&gt; &lt;!-- 卡片的头部 --&gt; &lt;v-card-title&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;!-- 分割线 --&gt; &lt;v-divider/&gt; &lt;!--卡片的中部--&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/v-card&gt; 效果： 添加搜索框我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 12345&lt;v-card-title&gt; &lt;v-btn color=\"primary\"&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\"/&gt;&lt;/v-card-title&gt; 效果： 发现输入框变的超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 1234567&lt;v-card-title&gt; &lt;v-btn color=\"primary\"&gt;新增品牌&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\"/&gt;&lt;/v-card-title&gt; 给搜索框添加搜索图标查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\" append-icon=\"search\"/&gt; 把文本框变紧凑搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\" append-icon=\"search\" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 3.3.后台提供查询接口前台页面已经准备好，接下来就是后台提供数据接口了。 3.3.1.数据库表1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 3.3.2.实体类 12345678910@Table(name = \"tb_brand\")public class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; 3.3.3.mapper通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; 3.3.4.controller编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到ly-common中，提高复用性： 接下来，我们编写Controller 123456789101112131415161718192021@RestController@RequestMapping(\"brand\")public class BrandController &#123; @Autowired private BrandService brandService; @GetMapping(\"page\") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = \"page\", defaultValue = \"1\") Integer page, @RequestParam(value = \"rows\", defaultValue = \"5\") Integer rows, @RequestParam(value = \"sortBy\", required = false) String sortBy, @RequestParam(value = \"desc\", defaultValue = \"false\") Boolean desc, @RequestParam(value = \"key\", required = false) String key) &#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key); if (result == null || result.getItems().size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; 3.3.5.Service123456789101112131415161718192021222324252627@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPageAndSort( Integer page, Integer rows, String sortBy, Boolean desc, String key) &#123; // 开始分页 PageHelper.startPage(page, rows); // 过滤 Example example = new Example(Brand.class); if (StringUtils.isNotBlank(key)) &#123; example.createCriteria().andLike(\"name\", \"%\" + key + \"%\") .orEqualTo(\"letter\", key); &#125; if (StringUtils.isNotBlank(sortBy)) &#123; // 排序 String orderByClause = sortBy + (desc ? \" DESC\" : \" ASC\"); example.setOrderByClause(orderByClause); &#125; // 查询 Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example); // 返回结果 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo); &#125;&#125; 完整结构： 3.3.6.测试通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 4.4.异步查询工具axios异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 4.3.1.axios入门Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get(\"/item/category/list?pid=0\") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get(\"/item/category/list\", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post(\"/user\",&#123; name:\"Jack\", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 4.3.2.axios的全局配置而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ ![1526041205846](assets/1526041205846.png) http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 4.3.3.测试一下：我们在组件MyBrand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： 控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 4.5.异步加载品牌数据虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们在getDataFromServer方法中完善请求参数： 12345678910111213141516// 发起请求this.$http.get(\"/item/brand/page\",&#123; params:&#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 // 将得到的数据赋值给本地属性 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) 查看网络请求： 效果： 4.6.完成分页和过滤4.6.1.分页现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 4.6.2.过滤分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 4.7.完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt; &lt;v-btn color=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-spacer/&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; v-model.lazy=&quot;search&quot; append-icon=&quot;search&quot; hide-details/&gt; &lt;/v-card-title&gt; &lt;v-divider/&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; import MyBrandForm from &apos;./MyBrandForm&apos; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125;, &#123;text: &apos;操作&apos;, align: &apos;center&apos;, value: &apos;id&apos;, sortable: false&#125; ] &#125; &#125;, mounted() &#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, watch: &#123; pagination: &#123; // 监视pagination属性的变化 deep: true, // deep为true，会监视pagination的属性及属性中的对象属性变化 handler() &#123; // 变化后的回调函数，这里我们再次调用getDataFromServer即可 this.getDataFromServer(); &#125; &#125;, search: &#123; // 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125; &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get(&quot;/item/brand/page&quot;, &#123; params: &#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"day04-乐优商城项目搭建","date":"2019-04-21T02:14:32.964Z","updated":"2018-10-28T11:35:34.115Z","comments":true,"path":"2019/04/21/day04-乐优商城项目搭建/","link":"","permalink":"https://mr8649.github.io/2019/04/21/day04-乐优商城项目搭建/","excerpt":"","text":"0.学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ![1525686041466](assets/1525686041466.png) 1.2.2.数据来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​ 2.乐优商城介绍吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 3.项目搭建吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 3.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.1版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf 3.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 3.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 3.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 填写保存的位置信息： 然后将pom文件修改成我这个样子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 3.5.创建EurekaServer3.5.1.创建工程这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 3.5.2.添加依赖添加EurekaServer的依赖： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.5.3.编写启动类1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 3.5.4.配置文件1234567891011121314server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 3.5.5.项目的结构：目前，整个项目的结构如图： 3.6.创建Zuul网关3.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 3.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 3.6.4.配置文件123456789101112131415161718192021222324252627282930server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;zuul: prefix: /api # 添加路由前缀 retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 10000 # 熔断超时时长：10000ms 3.6.5.项目结构目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-api-gateway：服务网关（Zuul） 目前，服务的结构如图所示： ![1525709241440](assets/1525709241440.png) 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 3.7.创建商品微服务吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 3.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 3.7.2.创建父工程ly-item依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 3.7.3.创建ly-item-interface在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ​ 3.7.4.创建ly-item-service与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 3.7.5.整个微服务结构如图所示： ​ 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ​ 3.7.6.添加依赖接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ly-item-interface中需要什么我们暂时不清楚，所以先不管。 整个结构： 3.7.7.编写启动和配置在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819202122server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: 123 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 3.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 3.9.启动测试我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 3.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 3.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 4、ES6 语法指南吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 4.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 4.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 4.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 4.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 结果： const const声明的变量是常量，不能被修改 4.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 4.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 4.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: \"jack\", // 以前： eat: function (food) &#123; console.log(this.name + \"在吃\" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + \"在吃\" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + \"在吃\" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log(\"hello,\" + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log(\"hello,\" + name); 4.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 4.3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： 4.3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 4.3.8.模块化4.3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 4.3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = \"jack\"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 4.3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + \" , 今年\"+ age +\"岁了\") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 4.3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 4.3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-11T07:31:32.815Z","updated":"2019-04-11T07:31:32.815Z","comments":true,"path":"2019/04/11/hello-world/","link":"","permalink":"https://mr8649.github.io/2019/04/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}