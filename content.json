{"meta":{"title":"不怕万人阻挡，就怕自己投降","subtitle":null,"description":null,"author":"xiaoyi","url":"https://mr8649.github.io"},"pages":[],"posts":[{"title":"分布式微服务系统商城项目环境搭建","slug":"分布式微服务系统商城项目环境搭建","date":"2019-05-03T02:44:51.000Z","updated":"2019-05-03T02:47:43.904Z","comments":true,"path":"2019/05/03/分布式微服务系统商城项目环境搭建/","link":"","permalink":"https://mr8649.github.io/2019/05/03/分布式微服务系统商城项目环境搭建/","excerpt":"","text":"# 0.学习目标 - 了解电商行业 - 了解乐优商城项目结构 - 能独立搭建项目基本框架 - 能参考使用ES6的新语法 # 1.了解电商行业 学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 ## 1.1.项目分类 主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 ### 1.1.1.传统项目 各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） - 需求方：公司、企业内部 - 盈利模式：项目本身卖钱 - 技术侧重点：业务功能 ### 1.1.2.互联网项目 门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… - 需求方：广大用户群体 - 盈利模式：虚拟币、增值服务、广告收益…… - 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 ## 1.2.电商行业的发展 ### 1.2.1.钱景 近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ​ ### 1.2.2.数据 来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 ### 1.2.3.技术特点 从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ - 技术范围广 - 技术新 - 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） - 高可用（集群、负载均衡、限流、降级、熔断） - 数据量大 - 业务复杂 - 数据安全 ## 1.3.常见电商模式 电商行业的一些常见模式： - B2C：商家对个人，如：亚马逊、当当等 - C2C平台：个人对个人，如：咸鱼、拍拍网、ebay - B2B平台：商家对商家，如：阿里巴巴、八方资源网等 - O2O：线上和线下结合，如：饿了么、电影票、团购等 - P2P：在线金融，贷款，如：网贷之家、人人聚财等。 - B2C平台：天猫、京东、一号店等 ## 1.4.一些专业术语 - SaaS：软件即服务 - SOA：面向服务 - RPC：远程过程调用 - RMI：远程方法调用 - PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 - UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 - PV与带宽： - 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 - 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） - 为什么要乘以8？ ​ - 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit - 这个计算的是平均带宽，高峰期还需要扩大一定倍数 - PV、QPS、并发 - QPS：每秒处理的请求数量。8000/s - 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 - 由PV和QPS如何需要部署的服务器数量？ ​ - 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： ​ - （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 - 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 ## 1.5.项目开发流程 项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： 公司现状： # 2.乐优商城介绍 ## 2.1.项目介绍 - 乐优商城是一个全品类的电商购物网站（B2C）。 - 用户可以在线购买商品、加入购物车、下单、秒杀商品 - 可以品论已购买商品 - 管理员可以在后台管理商品的上下架、促销活动 - 管理员可以监控商品销售状况 - 客服可以在后台处理退款操作 - 希望未来3到5年可以支持千万用户的使用 ## 2.2.系统架构 ### 2.2.1.架构图 乐优商城架构缩略图，大图请参考课前资料： ### 2.2.2.系统架构解读 整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 - 后台管理： - 后台系统主要包含以下功能： ​ - 商品管理，包括商品分类、品牌、商品规格等信息的管理 ​ - 销售管理，包括订单统计、订单退款处理、促销活动生成等 ​ - 用户管理，包括用户控制、冻结、解锁等 ​ - 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 ​ - 统计，各种数据的统计分析展示 - 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 - 预览图： - 前台门户 - 前台门户面向的是客户，包含与客户交互的一切功能。例如： ​ - 搜索商品 ​ - 加入购物车 ​ - 下单 ​ - 评价商品等等 - 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： - 商品微服务：商品及商品分类、品牌、库存等的服务 - 搜索微服务：实现搜索功能 - 订单微服务：实现订单相关 - 购物车微服务：实现购物车相关功能 - 用户中心：用户的登录注册等功能 - Eureka注册中心 - Zuul网关服务 - Spring Cloud Config配置中心 - … # 3.项目搭建 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 ## 3.1.技术选型 前端技术： - 基础的HTML、CSS、JavaScript（基于ES6标准） - JQuery - Vue.js 2.0以及基于Vue的框架：Vuetify - 前端构建工具：WebPack - 前端安装包工具：NPM - Vue脚手架：Vue-cli - Vue路由：vue-router - ajax框架：axios - 基于Vue的富文本框架：quill-editor 后端技术： - 基础的SpringMVC、Spring 5.0和MyBatis3 - Spring Boot 2.0.1版本 - Spring Cloud 最新版 Finchley.RC1 - Redis-4.0 - RabbitMQ-3.4 - Elasticsearch-5.6.8 - nginx-1.10.2： - FastDFS - 5.0.8 - MyCat - Thymeleaf ## 3.2.开发环境 为了保证开发环境的统一，希望每个人都按照我的环境来配置： - IDE：我们使用Idea 2017.3 版本 - JDK：统一使用JDK1.8 - 项目构建：maven3.3.9以上版本即可 - 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 ## 3.3.域名 我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 ## 3.4.创建父工程 创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 填写保存的位置信息： 然后将pom文件修改成我这个样子： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;​ &lt;artifactId&gt;leyou&lt;/artifactId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;packaging&gt;pom&lt;/packaging&gt;​ &lt;name&gt;leyou&lt;/name&gt;​ &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;​ &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;​ &lt;/parent&gt;​ &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt;​ &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt;​ &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt;​ &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt;​ &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt;​ &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt;​ &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt;​ &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt;​ &lt;/properties&gt;​ &lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;!-- springCloud --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;!-- mybatis启动器 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!-- 通用Mapper启动器 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!-- 分页助手启动器 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;​ &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!-- mysql驱动 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;​ &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!--FastDFS客户端--&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;​ &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;​ &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;​ &lt;/dependencyManagement&gt;​ &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt;​ &lt;/build&gt;​ &lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;​ &lt;/repositories&gt;&lt;/project&gt;\\ 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 ## 3.5.创建EurekaServer ### 3.5.1.创建工程 这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： ### 3.5.2.添加依赖 添加EurekaServer的依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;parent&gt;​ &lt;artifactId&gt;leyou&lt;/artifactId&gt;​ &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;/parent&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.common&lt;/groupId&gt;​ &lt;artifactId&gt;ly-registry&lt;/artifactId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/project&gt;\\ ### 3.5.3.编写启动类 \\12345678910111213141516@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123;​ public static void main(String[] args) &#123;​ SpringApplication.run(LyRegistry.class, args);​ &#125;&#125;\\ ### 3.5.4.配置文件 \\123456789101112131415161718192021222324252627282930server: port: 10086spring: application:​ name: ly-registryeureka: client:​ fetch-registry: false​ register-with-eureka: false​ service-url:​ defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server:​ enable-self-preservation: false # 关闭自我保护​ eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理\\ ### 3.5.5.项目的结构： 目前，整个项目的结构如图： ## 3.6.创建Zuul网关 ### 3.6.1.创建工程 与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： ### 3.6.2.添加依赖 这里我们需要添加Zuul和EurekaClient的依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;parent&gt;​ &lt;artifactId&gt;leyou&lt;/artifactId&gt;​ &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;/parent&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.common&lt;/groupId&gt;​ &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/project&gt;\\ ### 3.6.3.编写启动类 \\123456789101112131415161718@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123;​ public static void main(String[] args) &#123;​ SpringApplication.run(LyApiGateway.class, args);​ &#125;&#125;\\ ### 3.6.4.配置文件 \\1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162server: port: 10010spring: application:​ name: api-gatewayeureka: client:​ service-url:​ defaultZone: http://127.0.0.1:10086/eureka​ registry-fetch-interval-seconds: 5 instance:​ prefer-ip-address: true​ ip-address: 127.0.0.1​ instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;zuul: prefix: /api # 添加路由前缀 retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command:​ default:​ execution:​ isolation:​ thread:​ timeoutInMillisecond: 10000 # 熔断超时时长：10000ms\\ ### 3.6.5.项目结构 目前，leyou下有两个子模块： - ly-registry：服务的注册中心（EurekaServer） - ly-api-gateway：服务网关（Zuul） 目前，服务的结构如图所示： ​ 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 ## 3.7.创建商品微服务 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： - 商品分类管理 - 品牌管理 - 商品规格参数管理 - 商品管理 - 库存管理 我们先完成项目的搭建： ### 3.7.1.微服务的结构 因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： - ly-item-interface：主要是对外暴露的接口及相关实体类 - ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： ### 3.7.2.创建父工程ly-item 依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom \\12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;parent&gt;​ &lt;artifactId&gt;leyou&lt;/artifactId&gt;​ &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;/parent&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;​ &lt;artifactId&gt;ly-item&lt;/artifactId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;!-- 打包方式为pom --&gt;​ &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt;\\ ### 3.7.3.创建ly-item-interface 在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ### 3.7.4.创建ly-item-service 与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 ### 3.7.5.整个微服务结构 如图所示： 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ### 3.7.6.添加依赖 接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ - Eureka客户端 - web启动器 - mybatis启动器 - 通用mapper启动器 - 分页助手启动器 - 连接池，我们用默认的Hykira - mysql驱动 - 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;parent&gt;​ &lt;artifactId&gt;ly-item&lt;/artifactId&gt;​ &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;/parent&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;​ &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt;​ &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;​ &lt;dependencies&gt;​ &lt;!--Eureka客户端--&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;!--web启动器--&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;!-- mybatis启动器 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!-- 通用Mapper启动器 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!-- 分页助手启动器 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;​ &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;!-- mysql驱动 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;​ &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;​ &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt;​ &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/project&gt;\\ ly-item-interface中需要什么我们暂时不清楚，所以先不管。 整个结构： ### 3.7.7.编写启动和配置 在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： \\12345678910111213141516@SpringBootApplication@EnableDiscoveryClientpublic class LyItemService &#123;​ public static void main(String[] args) &#123;​ SpringApplication.run(LyItemService.class, args);​ &#125;&#125;\\ 然后是全局属性文件： \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546server: port: 8081spring: application:​ name: item-service datasource:​ url: jdbc:mysql://localhost:3306/heima​ username: root​ password: 123​ hikari:​ maximum-pool-size: 30​ minimum-idle: 10eureka: client:​ service-url:​ defaultZone: http://127.0.0.1:10086/eureka instance:​ lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳​ lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期​ prefer-ip-address: true​ ip-address: 127.0.0.1​ instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;\\ ## 3.8.添加商品微服务的路由规则 既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 \\123456789101112zuul: prefix: /api # 添加路由前缀 retryable: true routes:​ item-service: /item/** # 将商品微服务映射到/item/**\\ ## 3.9.启动测试 我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： ## 3.10.测试路由规则 为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： - /info - /health - /refresh - … 添加依赖： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\\ 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info ## 3.11.通用工具模块 有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 # 4、ES6 语法指南 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 ## 4.1.什么是ECMAScript？ 来看下前端的发展历程： > web1.0时代： - 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 > web2.0时代： - 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 - 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 - 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 ## 4.2.ECMAScript的快速发展 而后，ECMAScript就进入了快速发展期。 - 1998年6月，ECMAScript 2.0 发布。 - 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 - 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 - 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 - 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 - 2009年12月，ECMAScript 5 发布。 - 2011年6月，ECMAScript 5.1 发布。 - 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 ## 4.3.ES5和6的一些新特性 我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 ### 4.3.1.let 和 const 命令 > var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： \\12345678910for(var i = 0; i &lt; 5; i++)&#123;​ console.log(i);&#125;console.log(\"循环外：\" + i)\\ 你猜下打印的结果是什么？ > let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： \\12345678910for(let i = 0; i &lt; 5; i++)&#123;​ console.log(i);&#125;console.log(\"循环外：\" + i)\\ 结果： > const const声明的变量是常量，不能被修改 ### 4.3.2.字符串扩展 > 新的API ES6为字符串扩展了几个新的API： - includes()：返回布尔值，表示是否找到了参数字符串。 - startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 - endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： > 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 ### 4.3.3.解构表达式 > 数组解构 比如有一个数组： \\1234let arr = [1,2,3]\\ 我想获取其中的值，只能通过角标。ES6可以这样： \\12345678const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z);\\ 结果： > 对象解构 例如有个person对象： \\123456789101112const person = &#123;​ name:\"jack\",​ age:21,​ language: ['java','js','css']&#125;\\ 我们可以这么做： \\1234567891011121314// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language);\\ 结果： 如过想要用其它变量接收，需要额外指定别名： - {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 ### 4.3.4.函数优化 > 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： \\12345678910111213141516​ function add(a , b) &#123;​ // 判断b是否为空，为空就给默认值1​ b = b || 1;​ return a + b;​ &#125;​ // 传一个参数​ console.log(add(10));\\ 现在可以这么写： \\123456789101112function add(a , b = 1) &#123;​ return a + b;&#125;// 传一个参数console.log(add(10));\\ > 箭头函数 ES6中定义函数的简写方式： 一个参数时： \\123456789101112var print = function (obj) &#123;​ console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj);\\ 多个参数： \\1234567891011121314// 两个参数的情况：var sum = function (a , b) &#123;​ return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b;\\ 代码不止一行，可以用{}括起来 \\12345678var sum3 = (a,b) =&gt; &#123;​ return a + b;&#125;\\ > 对象的函数属性简写 比如一个Person对象，里面有eat方法： \\12345678910111213141516171819202122232425262728let person = &#123;​ name: \"jack\",​ // 以前：​ eat: function (food) &#123;​ console.log(this.name + \"在吃\" + food);​ &#125;,​ // 箭头函数版：​ eat2: food =&gt; console.log(person.name + \"在吃\" + food),// 这里拿不到this​ // 简写版：​ eat3(food)&#123;​ console.log(this.name + \"在吃\" + food);​ &#125;&#125;\\ > 箭头函数结合解构表达式 比如有一个函数： \\123456789101112131415161718const person = &#123;​ name:\"jack\",​ age:21,​ language: ['java','js','css']&#125;function hello(person) &#123;​ console.log(\"hello,\" + person.name)&#125;\\ 如果用箭头函数和解构表达式 \\1234var hi = (&#123;name&#125;) =&gt; console.log(\"hello,\" + name);\\ ### 4.3.5.map和reduce 数组中新增了map和reduce方法。 > map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 \\12345678910let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr)\\ > reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： - 第一个参数是上一次reduce处理的结果 - 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： \\1234const arr = [1,20,-5,3]\\ 没有初始值： 指定初始值： ### 4.3.6.promise 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： \\123456789101112131415161718const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123;​ resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123;​ reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;);\\ 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： \\12345678promise.then(function(value)&#123;​ // 异步执行成功后的回调&#125;);\\ 如果想要处理promise异步执行失败的事件，还可以跟上catch： \\123456789101112promise.then(function(value)&#123;​ // 异步执行成功后的回调&#125;).catch(function(error)&#123;​ // 异步执行失败后的回调&#125;)\\ 示例： \\1234567891011121314151617181920212223242526272829303132333435363738const p = new Promise(function (resolve, reject) &#123;​ // 这里我们用定时任务模拟异步​ setTimeout(() =&gt; &#123;​ const num = Math.random();​ // 随机返回成功或失败​ if (num &lt; 0.5) &#123;​ resolve(&quot;成功！num:&quot; + num)​ &#125; else &#123;​ reject(&quot;出错了！num:&quot; + num)​ &#125;​ &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123;​ console.log(msg);&#125;).catch(function (msg) &#123;​ console.log(msg);&#125;)\\ 结果： ### 4.3.7.set和map（了解） ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： \\123456789101112// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5]\\ 普通方法： \\1234567891011121314151617181920set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。\\ map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： - object是 &lt;string,object&gt;集合 - map是&lt;object,object&gt;集合 构造函数： \\12345678910111213141516171819202122232425262728// map接收一个数组，数组中的元素是键值对数组const map = new Map([​ ['key1','value1'],​ ['key2','value2'],])// 或者接收一个setconst set = new Set([​ ['key1','value1'],​ ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map);\\ 方法： ### 4.3.8.模块化 #### 4.3.8.1.什么是模块化 模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 - export命令用于规定模块的对外接口， - import命令用于导入其他模块提供的功能。 #### 4.3.8.2.export 比如我定义一个js文件:hello.js，里面有一个对象： \\123456789101112const util = &#123;​ sum(a,b)&#123;​ return a + b;​ &#125;&#125;\\ 我可以使用export将这个对象导出： \\1234567891011121314const util = &#123;​ sum(a,b)&#123;​ return a + b;​ &#125;&#125;export util;\\ 当然，也可以简写为： \\123456789101112export const util = &#123;​ sum(a,b)&#123;​ return a + b;​ &#125;&#125;\\ export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： \\12345678var name = \"jack\"var age = 21export &#123;name,age&#125;\\ > 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： \\1234567891011121314// 无需声明对象的名字export default &#123;​ sum(a,b)&#123;​ return a + b;​ &#125;&#125;\\ 这样，当使用者导入时，可以任意起名字 #### 4.3.8.3.import 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： \\12345678910// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2)\\ 要批量导入前面导出的name和age： \\123456import &#123;name, age&#125; from 'user.js'console.log(name + \" , 今年\"+ age +\"岁了\")\\ 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 ### 4.3.9.对象扩展 ES6给Object拓展了许多新的方法，如： - keys(obj)：获取对象的所有key形成的数组 - values(obj)：获取对象的所有value形成的数组 - entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] - assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 ### 4.3.10.数组扩展 ES6给数组新增了许多方法： - find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 - findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 - includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[],"tags":[],"keywords":[]},{"title":"认识微服务二","slug":"认识微服务二","date":"2019-05-03T02:37:37.000Z","updated":"2019-05-03T02:47:43.900Z","comments":true,"path":"2019/05/03/认识微服务二/","link":"","permalink":"https://mr8649.github.io/2019/05/03/认识微服务二/","excerpt":"","text":"# 0.学习目标 - 会配置Hystix熔断 - 会使用Feign进行远程调用 - 能独立搭建Zuul网关 - 能编写Zuul的拦截器 # 1.Hystix 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 ## 1.1.简介 Hystix，即熔断器。 主页：https://github.com/Netflix/Hystrix/ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 ## 1.2.熔断器的工作机制： 正常工作的情况下，客户端请求调用服务API接口： 当有服务出现异常时，直接进行失败回滚，服务降级处理： 当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 ## 1.3.动手实践 ### 1.3.1.引入依赖 首先在user-consumer中引入Hystix依赖： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;\\ ### 1.3.2.开启熔断 ### 1.3.2.改造消费者 我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数： \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Componentpublic class UserDao &#123;​ @Autowired​ private RestTemplate restTemplate;​ private static final Logger logger = LoggerFactory.getLogger(UserDao.class);​ @HystrixCommand(fallbackMethod = \"queryUserByIdFallback\")​ public User queryUserById(Long id)&#123;​ long begin = System.currentTimeMillis();​ String url = \"http://user-service/user/\" + id;​ User user = this.restTemplate.getForObject(url, User.class);​ long end = System.currentTimeMillis();​ // 记录访问用时：​ logger.info(\"访问用时：&#123;&#125;\", end - begin);​ return user;​ &#125;​ public User queryUserByIdFallback(Long id)&#123;​ User user = new User();​ user.setId(id);​ user.setName(\"用户信息查询出现异常！\");​ return user;​ &#125;&#125;\\ - @HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。 - 为了方便查看熔断的触发时机，我们记录请求访问时间。 在原来的业务逻辑中调用这个DAO： \\12345678910111213141516171819202122232425262728@Servicepublic class UserService &#123;​ @Autowired​ private UserDao userDao;​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.userDao.queryUserById(id));​ &#125;);​ return users;​ &#125;&#125;\\ ### 1.3.3.改造服务提供者 改造服务提供者，随机休眠一段时间，以触发熔断： \\12345678910111213141516171819202122@Servicepublic class UserService &#123;​ @Autowired​ private UserMapper userMapper;​ public User queryById(Long id) throws InterruptedException &#123;​ // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒​ Thread.sleep(new Random().nextInt(2000));​ return this.userMapper.selectByPrimaryKey(id);​ &#125;&#125;\\ ### 1.3.4.启动测试 然后运行并查看日志： id为9、10、11的访问时间分别是： id为12的访问时间： 因此，只有12是正常访问，其它都会触发熔断，我们来查看结果： ### 1.3.5.优化 虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 \\12345678910111213141516hystrix: command:​ default:​ execution:​ isolation:​ thread:​ timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms\\ # 2.Feign 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： \\123456String baseUrl = \"http://user-service/user/\";User user = this.restTemplate.getForObject(baseUrl + id, User.class)\\ 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 ## 2.1.简介 有道词典的英文解释： 为什么叫伪装？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign ## 2.2.快速入门 ### 2.2.1.导入依赖 \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\\ ### 2.2.2.Feign的客户端 \\123456789101112@FeignClient(\"user-service\")public interface UserFeignClient &#123;​ @GetMapping(\"/user/&#123;id&#125;\")​ User queryUserById(@PathVariable(\"id\") Long id);&#125;\\ - 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 - @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 - 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，不再调用UserDao： \\12345678910111213141516171819202122232425262728@Servicepublic class UserService &#123;​ @Autowired​ private UserFeignClient userFeignClient;​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.userFeignClient.queryUserById(id));​ &#125;);​ return users;​ &#125;&#125;\\ ### 2.2.3.开启Feign功能 我们在启动类上，添加注解，开启Feign功能 \\1234567891011121314151617181920@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ - 你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了 ### 2.2.4.启动测试： 访问接口： 正常获取到了结果。 ## 2.3.负载均衡 Feign中本身已经集成了Ribbon依赖和自动配置： 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置： \\12345678910111213141516user-service: ribbon:​ ConnectTimeout: 250 # 连接超时时间(ms)​ ReadTimeout: 1000 # 通信超时时间(ms)​ OkToRetryOnAllOperations: true # 是否对所有操作重试​ MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数​ MaxAutoRetries: 1 # 同一实例的重试次数\\ ## 2.4.Hystix支持 Feign默认也有对Hystix的集成： 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启： \\12345678feign: hystrix:​ enabled: true # 开启Feign的熔断功能\\ 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类 \\12345678910111213141516171819202122@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123;​ @Override​ public User queryUserById(Long id) &#123;​ User user = new User();​ user.setId(id);​ user.setName(\"用户查询出现异常！\");​ return user;​ &#125;&#125;\\ 2）然后在UserFeignClient中，指定刚才编写的实现类 \\123456789101112@FeignClient(value = \"user-service\", fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123;​ @GetMapping(\"/user/&#123;id&#125;\")​ User queryUserById(@PathVariable(\"id\") Long id);&#125;\\ 3）重启测试： 我们关闭user-service服务，然后在页面访问： ## 2.5.请求压缩(了解) Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： \\1234567891011121314feign: compression:​ request:​ enabled: true # 开启请求压缩​ response:​ enabled: true # 开启响应压缩\\ 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： \\1234567891011121314feign: compression:​ request:​ enabled: true # 开启请求压缩​ mime-types: text/html,application/xml,application/json # 设置压缩的数据类型​ min-request-size: 2048 # 设置触发压缩的大小下限\\ 注：上面的数据类型、压缩大小下限均为默认值。 ## 2.6.日志级别(了解) 前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug \\12345678logging: level:​ com.leyou: debug\\ 2）编写配置类，定义日志级别 \\12345678910111213141516@Configurationpublic class FeignConfig &#123;​ @Bean​ Logger.Level feignLoggerLevel()&#123;​ return Logger.Level.FULL;​ &#125;&#125;\\ 这里指定的Level级别是FULL，Feign支持4种级别： - NONE：不记录任何日志信息，这是默认值。 - BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 - HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 - FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： \\123456789101112@FeignClient(value = \"user-service\", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123;​ @GetMapping(\"/user/&#123;id&#125;\")​ User queryUserById(@PathVariable(\"id\") Long id);&#125;\\ 4）重启项目，即可看到每次访问的日志： # 3.Zuul网关 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： - 首先，破坏了服务无状态特点。 - 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 - 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 - 其次，无法直接复用既有接口。 - 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 ## 3.1.简介 官网：https://github.com/Netflix/zuul Zuul：维基百科： 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ ## 3.2.Zuul加入后的架构 - 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 ## 3.3.快速入门 ### 3.3.1.新建工程 填写基本信息： 添加Zuul依赖： ### 3.3.2.编写启动类 通过@EnableZuulProxy注解开启Zuul的功能： \\12345678910111213141516@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125;\\ ### 3.3.3.编写配置 \\123456789101112server: port: 10010 #服务端口spring: application: ​ name: api-gateway #指定服务名\\ ### 3.3.4.编写路由规则 我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态： - ip为：127.0.0.1 - 端口为：8081 映射规则： \\123456789101112zuul: routes:​ user-service: # 这里是路由id，随意写​ path: /user-service/** # 这里是映射路径​ url: http://127.0.0.1:8081 # 映射路径对应的实际url地址\\ 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:8081 ### 3.3.5.启动测试： 访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:8081/user-service/user/10 ## 3.4.面向服务的路由 在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ ### 3.4.1.添加Eureka客户端依赖 \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ ### 3.4.2.开启Eureka客户端发现功能 \\123456789101112131415161718@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125;\\ ### 3.4.3.添加Eureka配置，获取服务信息 \\123456789101112131415161718eureka: client:​ registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s​ service-url:​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true​ ip-address: 127.0.0.1\\ ### 3.4.4.修改映射配置，通过服务名称获取 因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 \\123456789101112zuul: routes:​ user-service: # 这里是路由id，随意写​ path: /user-service/** # 这里是映射路径​ serviceId: user-service # 指定服务名称\\ ### 3.4.5.启动测试 再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： 日志中可以看到使用了负载均衡器： ## 3.5.简化的路由配置 在刚才的配置中，我们的规则是这样的： - zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 - zuul.routes.&lt;route&gt;.serviceId=/user-service：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于user-service的配置可以简化为一条： \\12345678zuul: routes:​ user-service: /user-service/** # 这里是映射路径\\ 省去了对服务名称的配置。 ## 3.6.默认的路由规则 在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： - 默认情况下，一切服务的映射路径就是服务名本身。 - 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 ## 3.7.路由前缀 配置示例： \\1234567891011121314zuul: prefix: /api # 添加路由前缀 routes:​ user-service: # 这里是路由id，随意写​ path: /user-service/** # 这里是映射路径​ service-id: user-service # 指定服务名称\\ 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 ## 3.8.过滤器 Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 ### 3.8.1.ZuulFilter ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： \\12345678910111213141516public abstract ZuulFilter implements IZuulFilter&#123;​ abstract public String filterType();​ abstract public int filterOrder();​ ​ boolean shouldFilter();// 来自IZuulFilter​ Object run() throws ZuulException;// IZuulFilter&#125;\\ - shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 - run：过滤器的具体业务逻辑。 - filterType：返回字符串，代表过滤器的类型。包含以下4种： - pre：请求在被路由之前执行 - routing：在路由请求时调用 - post：在routing和errror过滤器之后调用 - error：处理请求时发生错误调用 - filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 ### 3.8.2.过滤器执行生命周期： 这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 - 正常流程： - 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 - 异常流程： - 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 - 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 - 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 所有内置过滤器列表： ### 3.8.3.使用场景 场景非常多： - 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 - 异常处理：一般会在error类型和post类型过滤器中结合来处理。 - 服务调用时长统计：pre和post结合使用。 ## 3.9.自定义过滤器 接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 ### 3.9.1.定义过滤器类 \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Componentpublic class LoginFilter extends ZuulFilter&#123;​ @Override​ public String filterType() &#123;​ // 登录校验，肯定是在前置拦截​ return \"pre\";​ &#125;​ @Override​ public int filterOrder() &#123;​ // 顺序设置为1​ return 1;​ &#125;​ @Override​ public boolean shouldFilter() &#123;​ // 返回true，代表过滤器生效。​ return true;​ &#125;​ @Override​ public Object run() throws ZuulException &#123;​ // 登录校验逻辑。​ // 1）获取Zuul提供的请求上下文对象​ RequestContext ctx = RequestContext.getCurrentContext();​ // 2) 从上下文中获取request对象​ HttpServletRequest req = ctx.getRequest();​ // 3) 从请求中获取token​ String token = req.getParameter(\"access-token\");​ // 4) 判断​ if(token == null || \"\".equals(token.trim()))&#123;​ // 没有token，登录校验失败，拦截​ ctx.setSendZuulResponse(false);​ // 返回401状态码。也可以考虑重定向到登录页。​ ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());​ &#125;​ // 校验通过，可以考虑把用户信息放入上下文，继续向后执行​ return null;​ &#125;&#125;\\ ### 3.9.2.测试 没有token参数时，访问失败： 添加token参数后： ## 3.10.负载均衡和熔断 Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： \\1234567891011121314151617181920212223242526272829303132zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command:​ default:​ execution:​ isolation:​ thread:​ timeoutInMillisecond: 6000 # 熔断超时时长：6000ms\\","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"day04-乐优商城项目搭建","date":"2019-05-03T02:33:41.726Z","updated":"2019-05-03T02:33:41.727Z","comments":true,"path":"2019/05/03/day04-乐优商城项目搭建/","link":"","permalink":"https://mr8649.github.io/2019/05/03/day04-乐优商城项目搭建/","excerpt":"","text":"0.学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ![1525686041466](assets/1525686041466.png) 1.2.2.数据来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​ 2.乐优商城介绍吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 3.项目搭建吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 3.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.1版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf 3.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 3.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 3.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 填写保存的位置信息： 然后将pom文件修改成我这个样子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 3.5.创建EurekaServer3.5.1.创建工程这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 3.5.2.添加依赖添加EurekaServer的依赖： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.5.3.编写启动类1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 3.5.4.配置文件1234567891011121314server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 3.5.5.项目的结构：目前，整个项目的结构如图： 3.6.创建Zuul网关3.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 3.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 3.6.4.配置文件123456789101112131415161718192021222324252627282930server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;zuul: prefix: /api # 添加路由前缀 retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 10000 # 熔断超时时长：10000ms 3.6.5.项目结构目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-api-gateway：服务网关（Zuul） 目前，服务的结构如图所示： ![1525709241440](assets/1525709241440.png) 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 3.7.创建商品微服务吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 3.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 3.7.2.创建父工程ly-item依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 3.7.3.创建ly-item-interface在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ​ 3.7.4.创建ly-item-service与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 3.7.5.整个微服务结构如图所示： ​ 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ​ 3.7.6.添加依赖接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ly-item-interface中需要什么我们暂时不清楚，所以先不管。 整个结构： 3.7.7.编写启动和配置在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819202122server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: 123 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 3.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 3.9.启动测试我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 3.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 3.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 4、ES6 语法指南吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 4.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 4.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 4.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 4.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 结果： const const声明的变量是常量，不能被修改 4.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 4.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 4.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: \"jack\", // 以前： eat: function (food) &#123; console.log(this.name + \"在吃\" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + \"在吃\" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + \"在吃\" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log(\"hello,\" + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log(\"hello,\" + name); 4.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 4.3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： 4.3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 4.3.8.模块化4.3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 4.3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = \"jack\"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 4.3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + \" , 今年\"+ age +\"岁了\") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 4.3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 4.3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot基础学习入门","slug":"SpringBoot基础学习入门","date":"2019-05-03T02:18:41.000Z","updated":"2019-05-03T02:21:30.750Z","comments":true,"path":"2019/05/03/SpringBoot基础学习入门/","link":"","permalink":"https://mr8649.github.io/2019/05/03/SpringBoot基础学习入门/","excerpt":"","text":"# 0.学习目标 - 了解SpringBoot的作用 - 掌握java配置的方式 - 了解SpringBoot自动配置原理 - 掌握SpringBoot的基本使用 - 了解Thymeleaf的基本使用 # 1. 了解SpringBoot 在这一部分，我们主要了解以下3个问题： - 什么是SpringBoot - 为什么要学习SpringBoot - SpringBoot的特点 ## 1.1.什么是SpringBoot SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： > Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： > 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 ## 1.2.为什么要学习SpringBoot java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： - 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 - 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ > Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 ## 1.3.SpringBoot的特点 Spring Boot 主要目标是： - 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 - 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 - 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 - 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 # 2.快速入门 接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ ## 2.1.创建工程 我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： ## 2.2.添加依赖 看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ ### 2.2.1.添加父工程坐标 \\123456789101112​ &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;​ &lt;/parent&gt;\\ ### 2.2.2.添加web启动器 为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： \\1234567891011121314​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;\\ 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 ### 2.2.3.管理jdk版本 默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： \\12345678​ &lt;properties&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;/properties&gt;\\ ### 2.2.4.完整pom \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;​ &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt;​ &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt;​ &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;​ &lt;properties&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;/properties&gt;​ &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;​ &lt;/parent&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/project&gt;\\ ## 2.3.启动类 Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： \\1234567891011121314@SpringBootApplicationpublic class Application &#123;​ public static void main(String[] args) &#123;​ SpringApplication.run(Application.class, args);​ &#125;&#125;\\ ## 2.4.编写controller 接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： \\12345678910111213141516@RestControllerpublic class HelloController &#123;​ @GetMapping(\"hello\")​ public String hello()&#123;​ return \"hello, spring boot!\";​ &#125;&#125;\\ ## 2.5.启动测试 接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： - 1）监听的端口是8080 - 2）SpringMVC的映射路径是：/ - 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ # 3.Java配置 在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： \\12345678910111213141516&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"​ init-method=\"init\" destroy-method=\"close\"&gt;​ &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt;​ &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt;​ &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;\\ 现在该怎么做呢？ ## 3.1.回顾历史 事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： - Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 - Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 - Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 ## 3.2.尝试java配置 java配置主要靠java类和一些注解，比较常用的注解有： - @Configuration：声明一个类作为配置类，代替xml文件 - @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 - @value：属性注入 - @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： \\123456789101112&lt;dependency&gt;​ &lt;groupId&gt;com.alibaba&lt;/groupId&gt;​ &lt;artifactId&gt;druid&lt;/artifactId&gt;​ &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;\\ 创建一个jdbc.properties文件，编写jdbc属性： \\12345678910jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123\\ 然后编写代码： \\1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration@PropertySource(\"classpath:jdbc.properties\")public class JdbcConfig &#123;​ @Value(\"$&#123;jdbc.url&#125;\")​ String url;​ @Value(\"$&#123;jdbc.driverClassName&#125;\")​ String driverClassName;​ @Value(\"$&#123;jdbc.username&#125;\")​ String username;​ @Value(\"$&#123;jdbc.password&#125;\")​ String password;​ @Bean​ public DataSource dataSource() &#123;​ DruidDataSource dataSource = new DruidDataSource();​ dataSource.setUrl(url);​ dataSource.setDriverClassName(driverClassName);​ dataSource.setUsername(username);​ dataSource.setPassword(password);​ return dataSource;​ &#125;&#125;\\ 解读： - @Configuration：声明我们JdbcConfig是一个配置类 - @PropertySource：指定属性文件的路径是:classpath:jdbc.properties - 通过@Value为属性注入值 - 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： \\1234567891011121314151617181920@RestControllerpublic class HelloController &#123;​ @Autowired​ private DataSource dataSource;​ @GetMapping(\"hello\")​ public String hello() &#123;​ return \"hello, spring boot!\" + dataSource;​ &#125;&#125;\\ 然后Debug运行并查看： 属性注入成功了！ ## 3.3.SpringBoot的属性注入 在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： \\1234567891011121314151617181920@ConfigurationProperties(prefix = \"jdbc\")public class JdbcProperties &#123;​ private String url;​ private String driverClassName;​ private String username;​ private String password;​ // ... 略​ // getters 和 setters&#125;\\ - 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 - prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 - 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 - 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： \\12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123;​ @Bean​ public DataSource dataSource(JdbcProperties jdbc) &#123;​ DruidDataSource dataSource = new DruidDataSource();​ dataSource.setUrl(jdbc.getUrl());​ dataSource.setDriverClassName(jdbc.getDriverClassName());​ dataSource.setUsername(jdbc.getUsername());​ dataSource.setPassword(jdbc.getPassword());​ return dataSource;​ &#125;&#125;\\ - 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 - 然后你可以通过以下方式注入JdbcProperties： - @Autowired注入 ​ \\123456​ @Autowired​ private JdbcProperties prop;​ \\ - 构造函数注入 ​ \\12345678910​ private JdbcProperties prop;​ public JdbcConfig(Jdbcproperties prop)&#123;​ this.prop = prop;​ &#125;​ \\ - 声明有@Bean的方法参数注入 ​ \\12345678910​ @Bean​ public Datasource dataSource(JdbcProperties prop)&#123;​ // ...​ &#125;​ \\ 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： - Relaxed binding：松散绑定 - 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 - meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 ​ ## 3.4、更优雅的注入 事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： \\123456789101112131415161718192021222324@Configurationpublic class JdbcConfig &#123;​ ​ @Bean​ // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中​ @ConfigurationProperties(prefix = \"jdbc\")​ public DataSource dataSource() &#123;​ DruidDataSource dataSource = new DruidDataSource();​ return dataSource;​ &#125;&#125;\\ 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 4.自动配置原理 使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： - 注解：@SpringBootApplication - run方法：SpringApplication.run() 我们分别来研究这两个部分。 ## 4.1.了解@SpringBootApplication 点击进入，查看源码： 这里重点的注解有3个： - @SpringBootConfiguration - @EnableAutoConfiguration - @ComponentScan ### 4.1.1.@SpringBootConfiguration 我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 ### 4.1.2.@EnableAutoConfiguration 关于这个注解，官网上有一段说明： > The second class-level annotation is @EnableAutoConfiguration. This annotation > tells Spring Boot to “guess” how you want to configure Spring, based on the jar > dependencies that you have added. Since spring-boot-starter-web added Tomcat > and Spring MVC, the auto-configuration assumes that you are developing a web > application and sets up Spring accordingly. 简单翻译以下： > 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 #### 4.1.3.@ComponentScan 我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： > 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 > > 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 ## 4.2.默认配置原理 ### 4.2.1默认配置类 通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： - 这些默认配置是在哪里定义的呢？ - 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： - redis - jms - amqp - jdbc - jackson - mongodb - jpa - solr - elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： - @Configuration：声明这个类是一个配置类 - @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 - @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ - @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 ### 4.2.2.默认配置属性 另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 ## 4.3.总结 SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： - 你引入了相关依赖 - 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 # 5.SpringBoot实践 接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User ## 5.1.整合SpringMVC 虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 ### 5.1.1.修改端口 查看SpringBoot的全局属性可知，端口通过以下方式配置： \\123456\\# 映射端口server.port=80\\ 重启服务后测试： ### 5.1.2.访问静态资源 现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： - classpath:/META-INF/resources/ - classpath:/resources/ - classpath:/static/ - classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： ### 5.1.3.添加拦截器 拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： > If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. > > If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： > 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 > > 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： \\12345678910111213141516171819202122232425262728293031323334public class LoginInterceptor implements HandlerInterceptor &#123;​ private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);​ @Override​ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;​ logger.debug(\"preHandle method is now running!\");​ return true;​ &#125;​ @Override​ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;​ logger.debug(\"postHandle method is now running!\");​ &#125;​ @Override​ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;​ logger.debug(\"afterCompletion method is now running!\");​ &#125;&#125;\\ 然后，我们定义配置类，注册拦截器： \\123456789101112131415161718192021222324252627282930313233343536373839404142@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123;​ /**​ \\* 通过@Bean注解，将我们定义的拦截器注册到Spring容器​ \\* @return​ */​ @Bean​ public LoginInterceptor loginInterceptor()&#123;​ return new LoginInterceptor();​ &#125;​ /**​ \\* 重写接口中的addInterceptors方法，添加自定义拦截器​ \\* @param registry​ */​ @Override​ public void addInterceptors(InterceptorRegistry registry) &#123;​ // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径​ registry.addInterceptor(this.loginInterceptor()).addPathPatterns(\"/**\");​ &#125;&#125;\\ 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 \\123456\\# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug\\ 再次运行查看： \\123456782018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running!\\ ## 5.2.整合jdbc和事务 spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;\\ 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;\\ 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional \\1234567891011121314151617181920212223242526@Servicepublic class UserService &#123;​ @Autowired​ private UserMapper userMapper;​ public User queryById(Long id)&#123;​ return this.userMapper.selectByPrimaryKey(id);​ &#125;​ @Transactional​ public void deleteById(Long id)&#123;​ this.userMapper.deleteByPrimaryKey(id);​ &#125;&#125;\\ ## 5.3.整合连接池 其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： \\1234567891011121314151617181920\\# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123\\# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10\\ 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： \\1234567891011121314&lt;!-- Druid连接池 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;com.alibaba&lt;/groupId&gt;​ &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;\\ 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： \\12345678910111213141516171819202122\\#初始化连接数spring.datasource.druid.initial-size=1\\#最小空闲连接spring.datasource.druid.min-idle=1\\#最大活动连接spring.datasource.druid.max-active=20\\#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true\\#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true\\ ## 5.4.整合mybatis ### 5.4.1.mybatis SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： \\1234567891011121314&lt;!--mybatis --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;\\ 配置，基本没有需要配置的： \\12345678910\\# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo\\# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml\\ 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 \\12345678@Mapperpublic interface UserMapper &#123;&#125;\\ ### 5.4.2.通用mapper 通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： \\1234567891011121314&lt;!-- 通用mapper --&gt;&lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\\ 不需要做任何配置就可以使用了。 \\12345678@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;\\ ## 5.5.启动测试 将controller进行简单改造： \\12345678910111213141516171819202122@RestControllerpublic class HelloController &#123;​ @Autowired​ private UserService userService;​ @GetMapping(\"/hello\")​ public User hello() &#123;​ User user = this.userService.queryById(8L);​ return user;​ &#125;&#125;\\ 我们启动项目，查看： # 6.Thymeleaf快速入门 SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ ## 6.1.为什么是Thymeleaf？ 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： - 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 - 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 - 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 - 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： ## 6.2.编写接口 编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 \\1234567891011121314151617181920@GetMapping(\"/all\")public String all(ModelMap model) &#123;​ // 查询用户​ List&lt;User&gt; users = this.userService.queryAll();​ // 放入模型​ model.addAttribute(\"users\", users);​ // 返回模板名称（就是classpath:/templates/目录下的html文件名）​ return \"users\";&#125;\\ ## 6.3.引入启动器 直接引入启动器： \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\\ SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： - 默认前缀：classpath:/templates/ - 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 ## 6.4.静态页面 根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;​ &lt;title&gt;首页&lt;/title&gt; &lt;style type=\"text/css\"&gt;​ table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125;​ table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125;​ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"text-align: center\"&gt;​ &lt;span style=\"color: darkslategray; font-size: 30px\"&gt;欢迎光临！&lt;/span&gt;​ &lt;hr/&gt; &lt;table class=\"list\"&gt;​ &lt;tr&gt;​ &lt;th&gt;id&lt;/th&gt;​ &lt;th&gt;姓名&lt;/th&gt;​ &lt;th&gt;用户名&lt;/th&gt;​ &lt;th&gt;年龄&lt;/th&gt;​ &lt;th&gt;性别&lt;/th&gt;​ &lt;th&gt;生日&lt;/th&gt;​ &lt;th&gt;备注&lt;/th&gt;​ &lt;/tr&gt;​ &lt;tr th:each=\"user : $&#123;users&#125;\"&gt;​ &lt;td th:text=\"$&#123;user.id&#125;\"&gt;1&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.name&#125;\"&gt;张三&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.userName&#125;\"&gt;zhangsan&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.age&#125;\"&gt;20&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.sex&#125; == 1 ? '男': '女'\"&gt;男&lt;/td&gt;​ &lt;td th:text=\"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;\"&gt;1980-02-30&lt;/td&gt;​ &lt;td th:text=\"$&#123;user.note&#125;\"&gt;1&lt;/td&gt;​ &lt;/tr&gt;​ &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\\ 我们看到这里使用了以下语法： - ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 - th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 - th:each：类似于c:foreach 遍历集合，但是语法更加简洁 - th:text：声明标签中的文本 ​ - 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 ​ - 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ ## 6.5.测试 接下来，我们打开页面测试一下： ## 6.6.模板缓存 Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： \\123456\\# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false\\ 注意： 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 eclipse中没有测试过。 我们可以修改页面，测试一下。","categories":[],"tags":[],"keywords":[]},{"title":"认识微服务","slug":"认识微服务","date":"2019-05-03T02:05:54.000Z","updated":"2019-05-03T02:12:32.425Z","comments":true,"path":"2019/05/03/认识微服务/","link":"","permalink":"https://mr8649.github.io/2019/05/03/认识微服务/","excerpt":"","text":"# 0.学习目标 - 了解系统架构的演变 - 了解RPC与Http的区别 - 掌握HttpClient的简单使用 - 知道什么是SpringCloud - 独立搭建Eureka注册中心 - 独立配置Robbin负载均衡 -Xms128m -Xmx128m # 1.系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 ## 1.1. 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： - 代码耦合，开发维护困难 - 无法针对不同模块进行针对性优化 - 无法水平扩展 - 单点容错率低，并发能力差 ## 1.2.垂直拆分 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： - 系统拆分实现了流量分担，解决了并发问题 - 可以针对不同模块进行优化 - 方便水平扩展，负载均衡，容错率提高 缺点： - 系统间相互独立，会有很多重复开发工作，影响开发效率 ## 1.3.分布式服务 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： - 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： - 系统间耦合度变高，调用关系错综复杂，难以维护 ## 1.4.服务治理（SOA） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ - 服务越来越多，需要管理每个服务的地址 - 调用关系错综复杂，难以理清依赖关系 - 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ - 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 - 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 - 动态监控服务状态监控报告，人为控制服务状态 缺点： - 服务间会有依赖关系，一旦某个环节出错会影响较大 - 服务关系复杂，运维、测试部署困难，不符合DevOps思想 ## 1.5.微服务 前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： - 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 - 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 - 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 - 自治：自治是说服务间互相独立，互不干扰 - 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 - 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 - 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 - 数据库分离：每个服务都使用自己的数据源 - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： # 2.远程调用方式 无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： - RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 - Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 ## 2.1.认识RPC RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： - 实现远程调用其他计算机的服务 - 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： ​ - 1）采用何种网络通讯协议？ ​ - 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 ​ - 2）数据传输的格式怎样？ ​ - 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 - 像调用本地服务一样调用远程服务 - 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC ## 2.2.认识Http Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 - RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 - Http中还定义了资源定位的路径，RPC中并不需要 - 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 - 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 - 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 ## 2.3.如何选择？ 既然两种方式都可以实现远程调用，我们该如何选择呢？ - 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 - 难度来看，RPC实现较为复杂，http相对比较简单 - 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： - 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 - 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 # 3.Http客户端工具 既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： - HttpClient - OKHttp - URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient ## 3.1.HttpClient ### 3.1.1.介绍 HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： - 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 - 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） - 支持HTTPS协议。 - 通过Http代理建立透明的连接。 - 自动处理Set-Cookie中的Cookie。 ### 3.1.2.使用 我们导入课前资料提供的demo工程：《http-demo》 发起get请求： \\1234567891011121314​ @Test​ public void testGet() throws IOException &#123;​ HttpGet request = new HttpGet(\"http://www.baidu.com\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);​ &#125;\\ 发起Post请求： \\123456789101112131415161718@Testpublic void testPost() throws IOException &#123;​ HttpPost request = new HttpPost(\"http://www.oschina.net/\");​ request.setHeader(\"User-Agent\",​ \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);&#125;\\ 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 \\1234567891011121314@Testpublic void testGetPojo() throws IOException &#123;​ HttpGet request = new HttpGet(\"http://localhost/hello\");​ String response = this.httpClient.execute(request, new BasicResponseHandler());​ System.out.println(response);&#125;\\ 我们实际得到的是一个json字符串： \\1234567891011121314151617181920212223242526&#123;​ \"id\": 8,​ \"userName\": \"liuyan\",​ \"password\": \"123456\",​ \"name\": \"柳岩\",​ \"age\": 21,​ \"sex\": 2,​ \"birthday\": \"1995-08-07T16:00:00.000+0000\",​ \"created\": \"2014-09-20T03:41:15.000+0000\",​ \"updated\": \"2014-09-20T03:41:15.000+0000\",​ \"note\": \"柳岩同学在传智播客学表演\"&#125;\\ 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 ### 3.1.3.Json转换工具 HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： #### 对象转json \\12345678910111213141516171819202122232425262728// json处理工具​ private ObjectMapper mapper = new ObjectMapper();​ @Test​ public void testJson() throws JsonProcessingException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化​ String json = mapper.writeValueAsString(user);​ System.out.println(\"json = \" + json);​ &#125;\\ 结果： #### json转普通对象 \\1234567891011121314151617181920212223242526272829303132// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化​ String json = mapper.writeValueAsString(user);​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ User result = mapper.readValue(json, User.class);​ System.out.println(\"result = \" + result);&#125;\\ 结果： #### json转集合 json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： \\123456789101112131415161718192021222324252627282930313233343536// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化,得到对象集合的json字符串​ String json = mapper.writeValueAsString(Arrays.asList(user, user));​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class));​ for (User u : users) &#123;​ System.out.println(\"u = \" + u);​ &#125;&#125;\\ 结果： #### json转任意复杂类型 当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 \\123456789101112131415161718192021222324252627282930313233343536// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123;​ User user = new User();​ user.setId(8L);​ user.setAge(21);​ user.setName(\"柳岩\");​ user.setUserName(\"liuyan\");​ // 序列化,得到对象集合的json字符串​ String json = mapper.writeValueAsString(Arrays.asList(user, user));​ // 反序列化，接收两个参数：json数据，反序列化的目标类字节码​ List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);​ for (User u : users) &#123;​ System.out.println(\"u = \" + u);​ &#125;&#125;\\ 结果： ## 3.3.Spring的RestTemplate Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： - HttpClient - OkHttp - JDK原生的URLConnection（默认的） 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： \\123456789101112131415161718192021222324@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123;​ // 默认的RestTemplate，底层是走JDK的URLConnection方式。​ return new RestTemplate(); &#125;&#125;\\ 在测试类中直接@Autowired注入： \\123456789101112131415161718192021222324@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123;​ User user = this.restTemplate.getForObject(\"http://localhost/hello\", User.class);​ System.out.println(user); &#125;&#125;\\ - 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 4.初始SpringCloud 微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ - 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 - 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 - 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 - 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 ## 4.1.简介 SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix - Eureka：注册中心 - Zuul：服务网关 - Ribbon：负载均衡 - Feign：服务调用 - Hystix：熔断器 以上只是其中一部分，架构图： ## 4.2.版本 SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： | Component | Edgware.SR3 | Finchley.RC1 | Finchley.BUILD-SNAPSHOT | | ————————- | ————– | —————- | ———————– | | spring-cloud-aws | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-bus | 1.3.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-cli | 1.4.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-commons | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-contract | 1.2.4.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-config | 1.4.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-netflix | 1.4.4.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-security | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-cloudfoundry | 1.1.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-consul | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-sleuth | 1.3.3.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-stream | Ditmars.SR3 | Elmhurst.RELEASE | Elmhurst.BUILD-SNAPSHOT | | spring-cloud-zookeeper | 1.2.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-boot | 1.5.10.RELEASE | 2.0.1.RELEASE | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-task | 1.2.2.RELEASE | 2.0.0.RC1 | 2.0.0.RELEASE | | spring-cloud-vault | 1.1.0.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-gateway | 1.0.1.RELEASE | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | | spring-cloud-openfeign | | 2.0.0.RC1 | 2.0.0.BUILD-SNAPSHOT | 接下来，我们就一一学习SpringCloud中的重要组件。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 5.微服务场景模拟 首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 ## 5.1.服务提供者 我们新建一个项目，对外提供查询用户的服务。 ### 5.1.1.Spring脚手架创建工程 借助于Spring提供的快速搭建工具： 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;​ &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;1.3.2&lt;/version&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;mysql&lt;/groupId&gt;​ &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;​ &lt;scope&gt;runtime&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;​ &lt;scope&gt;test&lt;/scope&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;\\ 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： \\123456789101112&lt;dependency&gt;​ &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;​ &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;​ &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\\ 非常快捷啊！ ### 5.1.2.编写代码 添加一个对外查询的接口： \\12345678910111213141516171819202122@RestController@RequestMapping(\"user\")public class UserController &#123;​ @Autowired​ private UserService userService;​ @GetMapping(\"/&#123;id&#125;\")​ public User queryById(@PathVariable(\"id\") Long id) &#123;​ return this.userService.queryById(id);​ &#125;&#125;\\ Service： \\123456789101112131415161718@Servicepublic class UserService &#123;​ @Autowired​ private UserMapper userMapper;​ public User queryById(Long id) &#123;​ return this.userMapper.selectByPrimaryKey(id);​ &#125;&#125;\\ mapper: \\12345678@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;\\ 实体类： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Table(name = \"tb_user\")public class User implements Serializable &#123;​ private static final long serialVersionUID = 1L;​ @Id​ @GeneratedValue(strategy = GenerationType.IDENTITY)​ private Long id;​ // 用户名​ private String userName;​ // 密码​ private String password;​ // 姓名​ private String name;​ // 年龄​ private Integer age;​ // 性别，1男性，2女性​ private Integer sex;​ // 出生日期​ private Date birthday;​ // 创建时间​ private Date created;​ // 更新时间​ private Date updated;​ // 备注​ private String note; // 。。。省略getters和setters&#125;\\ 属性文件,这里我们采用了yaml语法，而不是properties： \\1234567891011121314151617181920212223242526server: port: 8081spring: datasource:​ url: jdbc:mysql://localhost:3306/mydb01​ username: root​ password: 123​ hikari:​ maximum-pool-size: 20​ minimum-idle: 10mybatis: type-aliases-package: com.leyou.userservice.pojo\\ 项目结构： ### 5.1.3.启动并测试： 启动项目，访问接口：http://localhost:8081/user/7 ## 5.2.服务调用者 ### 5.2.1.创建工程 与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： \\1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;​ &lt;/dependency&gt;​ &lt;!-- 添加OkHttp支持 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;​ &lt;artifactId&gt;okhttp&lt;/artifactId&gt;​ &lt;version&gt;3.9.0&lt;/version&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;\\ ### 5.2.2.编写代码 首先在启动类中注册RestTemplate： \\123456789101112131415161718192021222324@SpringBootApplicationpublic class UserConsumerDemoApplication &#123;​ @Bean​ public RestTemplate restTemplate() &#123;​ // 这次我们使用了OkHttp客户端,只需要注入工厂即可​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());​ &#125;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： \\1234567891011121314151617181920@Componentpublic class UserDao &#123;​ @Autowired​ private RestTemplate restTemplate;​ public User queryUserById(Long id)&#123;​ String url = \"http://localhost:8081/user/\" + id;​ return this.restTemplate.getForObject(url, User.class);​ &#125;&#125;\\ 然后编写user-service，循环查询UserDAO信息： \\12345678910111213141516171819202122232425262728@Servicepublic class UserService &#123;​ @Autowired​ private UserDao userDao;​ public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ for (Long id : ids) &#123;​ User user = this.userDao.queryUserById(id);​ users.add(user);​ &#125;​ return users;​ &#125;&#125;\\ 编写controller： \\12345678910111213141516171819202122@RestController@RequestMapping(\"consume\")public class ConsumerController &#123;​ @Autowired​ private UserService userService;​ @GetMapping​ public List&lt;User&gt; consume(@RequestParam(\"ids\") List&lt;Long&gt; ids) &#123;​ return this.userService.queryUserByIds(ids);​ &#125;&#125;\\ ### 5.2.3.启动测试： 因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume?ids=6,7,8 一个简单的远程服务调用案例就实现了。 ## 5.3.有没有问题？ 简单回顾一下，刚才我们写了什么： - use-service-demo：一个提供根据id查询用户的微服务 - consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ - 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 - consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 - consumer不清楚user-service的状态，服务宕机也不知道 - user-service只有1台服务，不具备高可用性 - 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： - 服务管理 - 如何自动注册和发现 - 如何实现状态监管 - 如何实现动态路由 - 服务如何实现负载均衡 - 服务如何解决容灾问题 - 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 6.Eureka注册中心 ## 6.1.认识Eureka 首先我们来解决第一问题，服务的管理。 > 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 > 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ > Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 ## 6.2.原理图 > 基本架构： - Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 - 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） - 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 - 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 ## 6.3.入门案例 ### 6.3.1.编写EurekaServer 接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;​ &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;​ &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt;​ &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;​ &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;​ &lt;java.version&gt;1.8&lt;/java.version&gt;​ &lt;!-- SpringCloud版本，是最新的F系列 --&gt;​ &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt;​ &lt;!-- Eureka服务端 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;​ &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt;​ &lt;plugins&gt;​ &lt;plugin&gt;​ &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;​ &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;​ &lt;/plugin&gt;​ &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;\\ 编写启动类： \\12345678910111213141516@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125;\\ 编写配置： \\123456789101112131415161718192021222324server: port: 10086 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true​ fetch-registry: false # 是否拉取其它服务的信息，默认是true​ service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。​ defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka\\ 启动服务，并访问：http://127.0.0.1:10086/eureka ### 6.3.2.将user-service注册到Eureka 注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 > 我们在user-service-demo中添加Eureka客户端依赖： 先添加SpringCloud依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;Finchley.RC1&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;&lt;/repositories&gt;\\ 然后是Eureka客户端： \\123456789101112&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ > 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 \\12345678910111213141516@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123;​ SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125;\\ > 编写配置 \\1234567891011121314151617181920212223242526272829303132333435363738394041424344server: port: 8081spring: datasource:​ url: jdbc:mysql://localhost:3306/mydb01​ username: root​ password: 123​ hikari:​ maximum-pool-size: 20​ minimum-idle: 10 application:​ name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client:​ service-url: # EurekaServer地址​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称​ ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找\\ 注意： - 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 - 不用指定register-with-eureka和fetch-registry，因为默认是true > 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 ### 6.3.3.消费者从Eureka获取服务 接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt;​ &lt;dependencies&gt;​ &lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;​ &lt;version&gt;Finchley.RC1&lt;/version&gt;​ &lt;type&gt;pom&lt;/type&gt;​ &lt;scope&gt;import&lt;/scope&gt;​ &lt;/dependency&gt;​ &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt;​ &lt;repository&gt;​ &lt;id&gt;spring-milestones&lt;/id&gt;​ &lt;name&gt;Spring Milestones&lt;/name&gt;​ &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;​ &lt;snapshots&gt;​ &lt;enabled&gt;false&lt;/enabled&gt;​ &lt;/snapshots&gt;​ &lt;/repository&gt;&lt;/repositories&gt;\\ 然后是Eureka客户端： \\123456789101112&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;​ &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\\ 2）在启动类开启Eureka客户端 \\123456789101112131415161718192021222324@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123;​ @Bean​ public RestTemplate restTemplate() &#123;​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());​ &#125;​ public static void main(String[] args) &#123;​ SpringApplication.run(UserConsumerDemoApplication.class, args);​ &#125;&#125;\\ 3）修改配置： \\1234567891011121314151617181920212223242526server: port: 8080spring: application:​ name: consumer # 应用名称eureka: client:​ service-url: # EurekaServer地址​ defaultZone: http://127.0.0.1:10086/eureka instance:​ prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname​ ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找\\ 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： \\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class UserService &#123;​ @Autowired​ private RestTemplate restTemplate;​ @Autowired​ private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ // String baseUrl = \"http://localhost:8081/user/\";​ // 根据服务名称，获取服务实例​ List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"user-service\");​ // 因为只有一个UserService,因此我们直接get(0)获取​ ServiceInstance instance = instances.get(0);​ // 获取ip和端口信息​ String baseUrl = \"http://\"+instance.getHost() + \":\" + instance.getPort()+\"/user/\";​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.restTemplate.getForObject(baseUrl + id, User.class));​ // 每次间隔500毫秒​ try &#123;​ Thread.sleep(500);​ &#125; catch (InterruptedException e) &#123;​ e.printStackTrace();​ &#125;​ &#125;);​ return users;​ &#125;&#125;\\ 5）Debug跟踪运行： 生成的URL： 访问结果： ## 6.4.Eureka详解 接下来我们详细讲解Eureka的原理及配置。 ### 6.4.1.基础架构 Eureka架构中的三个核心角色： - 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo - 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo - 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo ### 6.4.2.高可用的Eureka Server Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 > 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 > 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： \\1234567891011121314151617181920server: port: 10086 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087​ defaultZone: http://127.0.0.1:10087/eureka\\ 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： - 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 - 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： \\1234567891011121314151617181920server: port: 10087 # 端口spring: application:​ name: eureka-server # 应用名称，会在Eureka中显示eureka: client:​ service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087​ defaultZone: http://127.0.0.1:10086/eureka\\ 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： \\12345678910eureka: client:​ service-url: # EurekaServer地址,多个地址以','隔开​ defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka\\ ### 6.4.3.服务提供者 服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 > 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 > 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： \\12345678910eureka: instance:​ lease-expiration-duration-in-seconds: 90​ lease-renewal-interval-in-seconds: 30\\ - lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 - lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 \\12345678910eureka: instance:​ lease-expiration-duration-in-seconds: 10 # 10秒即过期​ lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\\ > 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： - UP(1)：代表现在是启动了1个示例，没有集群 - DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， - 默认格式是：${hostname} + ${spring.application.name} + ${server.port} - instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： \\12345678eureka: instance:​ instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;\\ 重启服务再试试看： ### 6.4.4.服务消费者 > 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： \\12345678eureka: client:​ registry-fetch-interval-seconds: 5\\ 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 ### 6.4.5.失效剔除和自我保护 > 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S > 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： \\12345678910eureka: server:​ enable-self-preservation: false # 关闭自我保护模式（缺省为打开）​ eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）\\ 吾爱程序猿（www.52programer.com）打造专业优质的IT教程分享社区 # 7.负载均衡Robbin 在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 ## 7.1.启动两个服务实例 首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： ## 7.2.开启负载均衡 因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： \\123456789101112@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123;​ return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125;\\ 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class UserService &#123;​ @Autowired​ private RestTemplate restTemplate;​ @Autowired​ private DiscoveryClient discoveryClient;​ public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123;​ List&lt;User&gt; users = new ArrayList&lt;&gt;();​ // 地址直接写服务名称即可​ String baseUrl = \"http://user-service/user/\";​ ids.forEach(id -&gt; &#123;​ // 我们测试多次查询，​ users.add(this.restTemplate.getForObject(baseUrl + id, User.class));​ // 每次间隔500毫秒​ try &#123;​ Thread.sleep(500);​ &#125; catch (InterruptedException e) &#123;​ e.printStackTrace();​ &#125;​ &#125;);​ return users;​ &#125;&#125;\\ 访问页面，查看结果： 完美！ ## 7.3.源码跟踪 为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： ## 7.4.负载均衡策略 Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： \\12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123;​ @Autowired​ RibbonLoadBalancerClient client;​ @Test​ public void test()&#123;​ for (int i = 0; i &lt; 100; i++) &#123;​ ServiceInstance instance = this.client.choose(\"user-service\");​ System.out.println(instance.getHost() + \":\" + instance.getPort());​ &#125;​ &#125;&#125;\\ 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： \\12345678user-service: ribbon:​ NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\\ 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： ## 7.5.重试机制 Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： \\1234567891011121314151617181920212223242526spring: cloud:​ loadbalancer:​ retry:​ enabled: true # 开启Spring Cloud的重试功能user-service: ribbon:​ ConnectTimeout: 250 # Ribbon的连接超时时间​ ReadTimeout: 1000 # Ribbon的数据读取超时时间​ OkToRetryOnAllOperations: true # 是否对所有操作都进行重试​ MaxAutoRetriesNextServer: 1 # 切换实例的重试次数​ MaxAutoRetries: 1 # 对当前实例的重试次数\\ 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 \\12345678910&lt;dependency&gt;​ &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;​ &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt;\\ 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！","categories":[],"tags":[],"keywords":[]}]}